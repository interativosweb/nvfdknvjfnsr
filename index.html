<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GeoLab - Vers√£o Est√°vel</title>
  <style>
    :root{
      --primary:#4f46e5;
      --secondary:#db2777;
      --accent:#f59e0b;
      --bg-color:#f3f4f6;
      --panel-bg:#ffffff;
      --text:#1f2937;
      --border:#e5e7eb;
    }

    body{
      font-family:'Segoe UI', Roboto, Helvetica, sans-serif;
      background-color:var(--bg-color);
      color:var(--text);
      margin:0;
      height:100vh;
      display:flex;
      overflow:hidden;
    }

    /* --- ESQUERDA: CONTROLES --- */
    .sidebar-left{
      width:300px;
      background:var(--panel-bg);
      border-right:1px solid var(--border);
      display:flex;
      flex-direction:column;
      z-index:20;
      box-shadow:4px 0 15px rgba(0,0,0,0.05);
    }

    .scroll-area{ flex:1; overflow-y:auto; padding:15px; }
    .header-box{ padding:15px; border-bottom:1px solid var(--border); background:#f9fafb; }

    h1{ font-size:1.4rem; color:var(--primary); margin:0; font-weight:800; }
    h2{
      font-size:0.8rem; color:#6b7280; text-transform:uppercase;
      border-bottom:2px solid #eee; padding-bottom:5px;
      margin:15px 0 10px 0; font-weight:700;
    }

    .control-group{
      background:#f8fafc;
      padding:10px;
      border-radius:6px;
      border:1px solid var(--border);
      margin-bottom:10px;
    }

    /* ‚úÖ anima√ß√£o em TODOS os bot√µes */
    button{
      width:100%;
      padding:8px;
      border:none;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
      margin-bottom:6px;
      font-size:0.85rem;
      transition: transform .12s ease, box-shadow .12s ease, filter .12s ease, background .2s ease, border-color .2s ease;
      will-change: transform;
    }
    button:hover{
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0,0,0,0.12);
      filter: brightness(1.02);
    }
    button:active{
      transform: translateY(0px) scale(0.98);
      box-shadow: 0 6px 18px rgba(0,0,0,0.10);
    }

    .btn-primary{ background:var(--primary); color:white; }
    .btn-primary:hover{ background:#4338ca; }

    .btn-danger{ background:#ef4444; color:white; }
    .btn-success{ background:#10b981; color:white; }

    .btn-anim{
      background:#3b82f6; color:white;
      display:flex; align-items:center; justify-content:center; gap:6px;
    }
    .btn-anim.active{
      background:#1d4ed8;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
    }

    .btn-toggle{
      background:white;
      border:1px solid #ccc;
      color:#555;
    }
    .btn-toggle.active{
      background:var(--secondary);
      color:white;
      border-color:var(--secondary);
    }

    input[type=range]{ width:100%; accent-color:var(--primary); margin:6px 0; }
    label{ display:flex; justify-content:space-between; font-size:0.8rem; color:#4b5563; }

    /* --- DIREITA: MENU FLUTUANTE DE FIGURAS (camadas) --- */
    .floating-layers{
      position:absolute;
      top:15px;
      right:15px;
      width:200px;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(10px);
      border:1px solid rgba(0,0,0,0.1);
      border-radius:12px;
      padding:10px;
      box-shadow:0 4px 20px rgba(0,0,0,0.1);
      z-index:30;
      max-height:80vh;
      overflow-y:auto;
    }

    .layer-item{
      padding:8px 10px;
      margin-bottom:4px;
      background: rgba(255,255,255,0.5);
      border:1px solid transparent;
      border-radius:10px;
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      align-items:center;
      transition: all .2s;
      font-size:0.85rem;
    }
    .layer-item:hover{ background:#f3f4f6; }
    .layer-item.active{
      background:white;
      border-color:var(--primary);
      box-shadow:0 2px 5px rgba(0,0,0,0.05);
      font-weight:800;
      color:var(--primary);
    }
    .layer-status{ width:8px; height:8px; border-radius:50%; background:#ddd; }
    .layer-item.active .layer-status{ background:var(--primary); }

    .speed-control{
      display:flex;
      justify-content:space-between;
      margin-top:6px;
      background: rgba(0,0,0,0.05);
      padding:4px;
      border-radius:8px;
    }
    .speed-btn{
      width:24px; height:24px;
      padding:0;
      margin:0;
      line-height:1;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#c7c7c7;
      color:white;
      border-radius:8px;
    }
    .speed-txt{
      font-size:0.72rem;
      font-weight:800;
      color:#555;
      align-self:center;
    }

    /* --- CANVAS --- */
    .main-content{
      flex:1;
      position:relative;
      background-image:
        linear-gradient(#e5e7eb 1px, transparent 1px),
        linear-gradient(90deg, #e5e7eb 1px, transparent 1px);
      background-size:40px 40px;
      overflow:hidden;
      cursor:default;
    }
    #canvas{ display:block; width:100%; height:100%; }

    .instruction{
      position:absolute;
      top:20px;
      left:50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.95);
      padding:8px 20px;
      border-radius:30px;
      box-shadow:0 4px 15px rgba(0,0,0,0.1);
      font-weight:800;
      color:var(--primary);
      pointer-events:none;
      border:1px solid var(--primary);
      font-size:0.9rem;
      z-index:10;
    }

    .footer{
      font-size:0.7rem;
      color:#9ca3af;
      text-align:center;
      padding:10px;
      border-top:1px solid var(--border);
    }

    /* --- BARRA INFERIOR: bot√£o + menu que abre pra cima --- */
    .bottom-toolbar{
      position:absolute;
      left:50%;
      bottom:14px;
      transform: translateX(-50%);
      z-index:25;
      user-select:none;
    }

    .geo-main-btn{
      width:auto;
      padding:12px 16px;
      border-radius:16px;
      background: rgba(255,255,255,0.92);
      border:1px solid rgba(0,0,0,0.12);
      backdrop-filter: blur(10px);
      display:flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.14);
      margin:0;
    }
    .geo-main-btn .dot{
      width:10px; height:10px; border-radius:999px; background: var(--primary);
      box-shadow: 0 0 0 3px rgba(79,70,229,0.15);
    }
    .geo-main-btn .chev{
      margin-left:6px;
      opacity:.8;
      transition: transform .18s ease;
    }
    .bottom-toolbar.open .geo-main-btn .chev{ transform: rotate(180deg); }

    .geo-menu{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
      bottom:60px;
      width:260px;
      background: rgba(255,255,255,0.92);
      border:1px solid rgba(0,0,0,0.12);
      border-radius:18px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.18);
      backdrop-filter: blur(12px);
      padding:10px;
      display:none;
      flex-direction:column;
      gap:6px;
      max-height: 58vh;
      overflow:auto;
    }
    .bottom-toolbar.open .geo-menu{ display:flex; }

    .geo-item{
      width:100%;
      background: rgba(255,255,255,0.75);
      border:1px solid rgba(0,0,0,0.08);
      color:#111827;
      border-radius:14px;
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin:0;
    }
    .geo-item .left{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:800;
    }
    .geo-icon{
      width:28px; height:28px;
      border-radius:10px;
      background: rgba(79,70,229,0.10);
      border:1px solid rgba(79,70,229,0.18);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:0.95rem;
    }
    .geo-item small{ opacity:.7; font-weight:800; }
  </style>
</head>

<body>
  <aside class="sidebar-left">
    <div class="header-box">
      <h1>üìê GeoLab</h1>
      <p style="font-size:0.75rem; margin:0; color:#666">Laborat√≥rio de Matem√°tica</p>
    </div>

    <div class="scroll-area" id="controlsPanel" style="display:none">
      <div class="control-group" style="border-left: 3px solid var(--accent);">
        <h2 style="margin-top:0; color:var(--accent); display:flex; justify-content:space-between;">
          Centro da Figura
        </h2>
        <p style="font-size:0.7rem; color:#666; margin-bottom:6px;">Arraste o ponto laranja para mudar o eixo.</p>
        <button class="btn-toggle" onclick="resetAnchor()" style="font-size:0.75rem">Resetar Centro</button>
      </div>

      <div class="control-group">
        <h2>Transla√ß√£o</h2>
        <label>X: <span id="valTx">0</span></label>
        <input type="range" id="inputTx" min="-350" max="350" oninput="updateShapeData()">
        <button class="btn-anim" id="animXBtn" onclick="toggleAnim('x')">‚ñ∂ Animar X</button>

        <label>Y: <span id="valTy">0</span></label>
        <input type="range" id="inputTy" min="-350" max="350" oninput="updateShapeData()">
        <button class="btn-anim" id="animYBtn" onclick="toggleAnim('y')">‚ñ∂ Animar Y</button>

        <div class="speed-control">
          <button class="speed-btn" onclick="changeSpeed('trans', -1)">-</button>
          <span class="speed-txt">Velocidade: <span id="speedTransDisplay">1x</span></span>
          <button class="speed-btn" onclick="changeSpeed('trans', 1)">+</button>
        </div>
      </div>

      <div class="control-group">
        <h2>Rota√ß√£o</h2>
        <label>√Çngulo: <span id="valRot">0¬∞</span></label>
        <input type="range" id="inputRot" min="0" max="360" oninput="updateShapeData()">
        <button class="btn-anim" id="animRotBtn" onclick="toggleAnim('rot')">‚ñ∂ Animar Rota√ß√£o</button>

        <div class="speed-control">
          <button class="speed-btn" onclick="changeSpeed('rot', -1)">-</button>
          <span class="speed-txt">Velocidade: <span id="speedRotDisplay">1x</span></span>
          <button class="speed-btn" onclick="changeSpeed('rot', 1)">+</button>
        </div>
      </div>

      <!-- TAMANHO -->
      <div class="control-group">
        <h2>Tamanho</h2>
        <label>Escala: <span id="valScale">100%</span></label>
        <input type="range" id="inputScale" min="30" max="260" value="100" oninput="updateShapeData()">
        <button class="btn-toggle" onclick="resetScale()">Resetar Tamanho</button>
      </div>

      <div class="control-group">
        <h2>Simetria (Espelho)</h2>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:6px;">
          <button id="btnRefX" class="btn-toggle" onclick="toggleReflect('x')">Espelho X</button>
          <button id="btnRefY" class="btn-toggle" onclick="toggleReflect('y')">Espelho Y</button>
        </div>
      </div>

      <button class="btn-danger" onclick="deleteCurrentLayer()" style="margin-top:10px;">üóëÔ∏è Excluir Figura</button>
    </div>

    <div class="scroll-area" id="emptyStateMsg" style="text-align:center; color:#999; display:flex; flex-direction:column; justify-content:center;">
      <p>Nenhuma figura selecionada.</p>
    </div>

    <div class="footer">
      Desenvolvido por Gilberto Fernandes - Matem√°tica
    </div>
  </aside>

  <main class="main-content" id="mainArea">
    <div class="instruction" id="instructionText">Clique em "+ Nova Figura" para come√ßar</div>
    <canvas id="canvas"></canvas>

    <!-- Barra inferior com 1 bot√£o -->
    <div class="bottom-toolbar" id="bottomToolbar">
      <button class="geo-main-btn" id="geoMainBtn" type="button" aria-label="Abrir figuras geom√©tricas">
        <span class="dot"></span>
        <span style="font-weight:900;">Figuras Geom√©tricas</span>
        <span class="chev">‚ñæ</span>
      </button>

      <div class="geo-menu" id="geoMenu" role="menu" aria-label="Menu de figuras">
        <button class="geo-item" type="button" onclick="addPresetShape('circle')">
          <span class="left"><span class="geo-icon">‚óØ</span> C√≠rculo</span><small>2D</small>
        </button>
        <button class="geo-item" type="button" onclick="addPresetShape('square')">
          <span class="left"><span class="geo-icon">‚ñ¢</span> Quadrado</span><small>2D</small>
        </button>
        <button class="geo-item" type="button" onclick="addPresetShape('rect')">
          <span class="left"><span class="geo-icon">‚ñ≠</span> Ret√¢ngulo</span><small>2D</small>
        </button>
        <button class="geo-item" type="button" onclick="addPresetShape('triangle')">
          <span class="left"><span class="geo-icon">‚ñ≥</span> Tri√¢ngulo</span><small>2D</small>
        </button>
        <button class="geo-item" type="button" onclick="addPresetShape('hex')">
          <span class="left"><span class="geo-icon">‚¨°</span> Hex√°gono</span><small>2D</small>
        </button>
        <button class="geo-item" type="button" onclick="addPresetShape('pent')">
          <span class="left"><span class="geo-icon">‚¨†</span> Pent√°gono</span><small>2D</small>
        </button>
      </div>
    </div>
  </main>

  <div class="floating-layers">
    <button class="btn-success" onclick="createNewLayer()" style="margin-bottom:10px; width:100%; padding:10px;">
      + Nova Figura
    </button>
    <div id="layersList"></div>
  </div>

<script>
/* =========================================================
   BLOQUEIOS B√ÅSICOS (dificulta, n√£o √© 100% infal√≠vel)
========================================================= */
(function hardenPage(){
  document.addEventListener('contextmenu', (e)=>e.preventDefault(), {capture:true});
  document.addEventListener('dragstart', (e)=>e.preventDefault(), {capture:true});
  document.addEventListener('selectstart', (e)=>{
    const tag = e.target?.tagName?.toLowerCase?.() || '';
    if(tag === 'input' || tag === 'textarea') return;
    e.preventDefault();
  }, {capture:true});

  document.addEventListener('keydown', (e)=>{
    const key = (e.key || '').toLowerCase();
    if(e.key === 'F12'){ e.preventDefault(); e.stopPropagation(); return false; }
    if(e.ctrlKey && e.shiftKey && (key==='i' || key==='j' || key==='c')){
      e.preventDefault(); e.stopPropagation(); return false;
    }
    if(e.ctrlKey && (key==='u' || key==='s')){
      e.preventDefault(); e.stopPropagation(); return false;
    }
    if(e.metaKey && (key==='u' || key==='s')){
      e.preventDefault(); e.stopPropagation(); return false;
    }
  }, {capture:true});
})();

/* =========================================================
   APP
========================================================= */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const mainArea = document.getElementById('mainArea');

let shapes = [];
let activeIndex = -1;
let mode = 'IDLE';
let mouseScreen = { x: 0, y: 0 }; // coords na tela (canvas)
let mouseWorld  = { x: 0, y: 0 }; // coords no mundo (ap√≥s zoom/pan)
let dragStartWorld = { x: 0, y: 0 };

// ZOOM (scroll do mouse)
let view = {
  scale: 1.0,
  offsetX: 0,
  offsetY: 0,
  minScale: 0.3,
  maxScale: 4.0
};

const colors = ['#4f46e5', '#059669', '#d97706', '#7c3aed', '#db2777'];

function resizeCanvas(){
  canvas.width = mainArea.clientWidth;
  canvas.height = mainArea.clientHeight;

  // centraliza o "mundo" no centro da tela (inicial)
  if (view.offsetX === 0 && view.offsetY === 0) {
    view.offsetX = 0;
    view.offsetY = 0;
  }

  draw();
}
window.addEventListener('resize', resizeCanvas);
setTimeout(resizeCanvas, 100);

/* ===================== MENU INFERIOR ===================== */
const bottomToolbar = document.getElementById('bottomToolbar');
const geoMainBtn = document.getElementById('geoMainBtn');
const geoMenu = document.getElementById('geoMenu');

function toggleGeoMenu(){
  bottomToolbar.classList.toggle('open');
}
geoMainBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  toggleGeoMenu();
});
document.addEventListener('click', ()=>{
  bottomToolbar.classList.remove('open');
});
geoMenu.addEventListener('click', (e)=>e.stopPropagation());

/* ===================== FUN√á√ïES DE COORDENADAS ===================== */
function screenToWorld(x, y){
  return {
    x: (x - view.offsetX) / view.scale,
    y: (y - view.offsetY) / view.scale
  };
}
function worldToScreen(x, y){
  return {
    x: x * view.scale + view.offsetX,
    y: y * view.scale + view.offsetY
  };
}

/* ===================== ZOOM COM SCROLL ===================== */
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;

  const before = screenToWorld(sx, sy);

  const zoomIn = e.deltaY < 0;
  const factor = zoomIn ? 1.12 : 0.88;

  const newScale = Math.max(view.minScale, Math.min(view.maxScale, view.scale * factor));
  view.scale = newScale;

  // mant√©m o ponto sob o mouse no mesmo lugar da tela
  view.offsetX = sx - before.x * view.scale;
  view.offsetY = sy - before.y * view.scale;

  // atualiza mouseWorld e redesenha
  mouseScreen = {x: sx, y: sy};
  mouseWorld = screenToWorld(sx, sy);
  draw();
}, { passive: false });

/* ===================== GERENCIAMENTO ===================== */
function createNewLayer(){
  const newShape = {
    id: Date.now(),
    name: `Figura ${shapes.length + 1}`,
    points: [],
    color: colors[shapes.length % colors.length],
    isClosed: false,
    tx: 0, ty: 0, rotation: 0,
    scale: 1.0,
    reflectX: false, reflectY: false,
    anchor: { x: 0, y: 0 },
    anim: { x: false, y: false, rot: false, dirX: 1, dirY: 1 },
    speed: { trans: 1.0, rot: 1.0 }
  };

  shapes.push(newShape);
  selectLayer(shapes.length - 1);
  mode = 'DRAWING';
  updateUI();
  document.getElementById('instructionText').style.display = 'block';
  document.getElementById('instructionText').innerText = `Criando ${newShape.name}: Clique para desenhar`;
}

function selectLayer(index){
  if(index < 0 || index >= shapes.length){
    activeIndex = -1;
    mode = 'IDLE';
  } else {
    if(activeIndex !== -1 && !shapes[activeIndex].isClosed){
      alert("Feche a forma atual antes de trocar.");
      return;
    }
    activeIndex = index;
    mode = shapes[index].isClosed ? 'IDLE' : 'DRAWING';
  }
  updateUI();
  draw();
}

function deleteCurrentLayer(){
  if(activeIndex === -1) return;
  shapes.splice(activeIndex, 1);
  activeIndex = -1;
  mode = 'IDLE';
  updateUI();
  draw();
}

function updateUI(){
  const layersList = document.getElementById('layersList');
  layersList.innerHTML = '';

  shapes.forEach((shape, idx)=>{
    const div = document.createElement('div');
    div.className = `layer-item ${idx === activeIndex ? 'active' : ''}`;
    div.onclick = ()=>selectLayer(idx);
    div.innerHTML = `<span class="layer-name">${shape.name}</span> <div class="layer-status"></div>`;
    layersList.appendChild(div);
  });

  const controls = document.getElementById('controlsPanel');
  const emptyMsg = document.getElementById('emptyStateMsg');

  if(activeIndex !== -1 && shapes[activeIndex].isClosed){
    controls.style.display = 'block';
    emptyMsg.style.display = 'none';

    const s = shapes[activeIndex];
    document.getElementById('inputTx').value = s.tx;
    document.getElementById('inputTy').value = s.ty;
    document.getElementById('inputRot').value = s.rotation;
    document.getElementById('inputScale').value = Math.round(s.scale * 100);

    document.getElementById('btnRefX').classList.toggle('active', s.reflectX);
    document.getElementById('btnRefY').classList.toggle('active', s.reflectY);

    document.getElementById('animXBtn').classList.toggle('active', s.anim.x);
    document.getElementById('animYBtn').classList.toggle('active', s.anim.y);
    document.getElementById('animRotBtn').classList.toggle('active', s.anim.rot);

    document.getElementById('instructionText').style.display = 'none';
    updateLabelValues();
  } else {
    controls.style.display = 'none';
    emptyMsg.style.display = 'flex';
  }
}

function updateShapeData(){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];

  s.tx = parseInt(document.getElementById('inputTx').value);
  s.ty = parseInt(document.getElementById('inputTy').value);
  s.rotation = parseInt(document.getElementById('inputRot').value);

  const sc = parseInt(document.getElementById('inputScale').value);
  s.scale = Math.max(0.30, Math.min(2.60, sc / 100));

  updateLabelValues();
  draw();
}

function updateLabelValues(){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  document.getElementById('valTx').innerText = s.tx;
  document.getElementById('valTy').innerText = -s.ty;
  document.getElementById('valRot').innerText = s.rotation + "¬∞";
  document.getElementById('valScale').innerText = Math.round(s.scale * 100) + "%";
  document.getElementById('speedTransDisplay').innerText = s.speed.trans + "x";
  document.getElementById('speedRotDisplay').innerText = s.speed.rot + "x";
}

function resetScale(){
  if(activeIndex === -1) return;
  shapes[activeIndex].scale = 1.0;
  document.getElementById('inputScale').value = 100;
  updateLabelValues();
  draw();
}

/* ===================== FIGURAS PREDEFINIDAS ===================== */
function addPresetShape(type){
  bottomToolbar.classList.remove('open');

  if(activeIndex !== -1 && shapes[activeIndex] && !shapes[activeIndex].isClosed){
    alert("Feche a forma atual antes de inserir uma figura pronta.");
    return;
  }

  // centro do mundo = centro da tela convertido pra world
  const worldCenter = screenToWorld(canvas.width/2, canvas.height/2);
  const cx = worldCenter.x;
  const cy = worldCenter.y;

  const size = 110;
  const pts = buildPresetPoints(type, cx, cy, size);

  const newShape = {
    id: Date.now(),
    name: `Figura ${shapes.length + 1}`,
    points: pts,
    kind: type,
    color: colors[shapes.length % colors.length],
    isClosed: true,
    tx: 0, ty: 0, rotation: 0,
    scale: 1.0,
    reflectX: false, reflectY: false,
    anchor: { x: 0, y: 0 },
    anim: { x: false, y: false, rot: false, dirX: 1, dirY: 1 },
    speed: { trans: 1.0, rot: 1.0 }
  };

  shapes.push(newShape);
  selectLayer(shapes.length - 1);
  mode = 'IDLE';
  updateUI();
  draw();
}

function buildPresetPoints(type, cx, cy, size){
  if(type === 'square'){
    const h = size/2;
    return [
      {x: cx-h, y: cy-h},
      {x: cx+h, y: cy-h},
      {x: cx+h, y: cy+h},
      {x: cx-h, y: cy+h}
    ];
  }

  if(type === 'rect'){
    const w = size * 1.35;
    const h = size * 0.75;
    return [
      {x: cx-w/2, y: cy-h/2},
      {x: cx+w/2, y: cy-h/2},
      {x: cx+w/2, y: cy+h/2},
      {x: cx-w/2, y: cy+h/2}
    ];
  }

  if(type === 'triangle'){
    const h = size * 0.95;
    return [
      {x: cx, y: cy - h/2},
      {x: cx + size/2, y: cy + h/2},
      {x: cx - size/2, y: cy + h/2}
    ];
  }

  if(type === 'circle'){
    return regularPolygonPoints(cx, cy, size/2, 64, -Math.PI/2);
  }

  if(type === 'pent'){
    return regularPolygonPoints(cx, cy, size/2, 5, -Math.PI/2);
  }

  if(type === 'hex'){
    return regularPolygonPoints(cx, cy, size/2, 6, -Math.PI/2);
  }

  return regularPolygonPoints(cx, cy, size/2, 6, -Math.PI/2);
}

function regularPolygonPoints(cx, cy, r, n, offset){
  const pts = [];
  for(let i=0;i<n;i++){
    const a = offset + (i/n) * Math.PI * 2;
    pts.push({x: cx + Math.cos(a)*r, y: cy + Math.sin(a)*r});
  }
  return pts;
}

/* ===================== INTERA√á√ÉO ===================== */
canvas.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  mouseScreen.x = e.clientX - rect.left;
  mouseScreen.y = e.clientY - rect.top;
  mouseWorld = screenToWorld(mouseScreen.x, mouseScreen.y);

  if(mode === 'DRAWING'){
    const s = shapes[activeIndex];
    if(s.points.length >= 3){
      const dx = mouseWorld.x - s.points[0].x;
      const dy = mouseWorld.y - s.points[0].y;
      if(Math.hypot(dx,dy) < 20){
        canvas.style.cursor = 'pointer';
        document.getElementById('instructionText').innerText = "Clique no in√≠cio para fechar!";
      } else {
        canvas.style.cursor = 'crosshair';
      }
    }
    draw();
    return;
  }

  if(mode === 'DRAGGING_ANCHOR'){
    const s = shapes[activeIndex];
    const center = getCentroid(s.points);
    s.anchor.x = mouseWorld.x - (center.x + s.tx);
    s.anchor.y = mouseWorld.y - (center.y + s.ty);
    draw();
    return;
  }

  if(mode === 'DRAGGING_SHAPE'){
    const dx = mouseWorld.x - dragStartWorld.x;
    const dy = mouseWorld.y - dragStartWorld.y;
    const s = shapes[activeIndex];
    s.tx += dx;
    s.ty += dy;
    document.getElementById('inputTx').value = Math.round(s.tx);
    document.getElementById('inputTy').value = Math.round(s.ty);
    updateLabelValues();
    dragStartWorld = { x: mouseWorld.x, y: mouseWorld.y };
    draw();
    return;
  }

  let cursor = 'default';
  if(activeIndex !== -1){
    const s = shapes[activeIndex];
    const center = getCentroid(s.points);
    const anchorX = center.x + s.tx + s.anchor.x;
    const anchorY = center.y + s.ty + s.anchor.y;
    if(Math.hypot(mouseWorld.x - anchorX, mouseWorld.y - anchorY) < 10) cursor = 'move';
    else if(isPointInShape(mouseWorld, s)) cursor = 'grab';
  } else {
    for(let i=shapes.length-1;i>=0;i--){
      if(shapes[i].isClosed && isPointInShape(mouseWorld, shapes[i])){ cursor='pointer'; break; }
    }
  }
  canvas.style.cursor = cursor;
});

canvas.addEventListener('mousedown', ()=>{
  if(mode === 'DRAWING'){
    const s = shapes[activeIndex];
    if(s.points.length >= 3){
      const dx = mouseWorld.x - s.points[0].x;
      const dy = mouseWorld.y - s.points[0].y;
      if(Math.hypot(dx,dy) < 20){
        s.isClosed = true;
        mode = 'IDLE';
        updateUI();
        draw();
        return;
      }
    }
    s.points.push({x: mouseWorld.x, y: mouseWorld.y});
    draw();
    return;
  }

  if(activeIndex !== -1){
    const s = shapes[activeIndex];
    const center = getCentroid(s.points);
    const anchorX = center.x + s.tx + s.anchor.x;
    const anchorY = center.y + s.ty + s.anchor.y;
    if(Math.hypot(mouseWorld.x - anchorX, mouseWorld.y - anchorY) < 10){
      mode = 'DRAGGING_ANCHOR';
      return;
    }
  }

  let clickedIndex = -1;
  if(activeIndex !== -1 && isPointInShape(mouseWorld, shapes[activeIndex])){
    clickedIndex = activeIndex;
  } else {
    for(let i=shapes.length-1;i>=0;i--){
      if(shapes[i].isClosed && isPointInShape(mouseWorld, shapes[i])){ clickedIndex=i; break; }
    }
  }

  if(clickedIndex !== -1){
    selectLayer(clickedIndex);
    mode = 'DRAGGING_SHAPE';
    dragStartWorld = { x: mouseWorld.x, y: mouseWorld.y };
    canvas.style.cursor = 'grabbing';
  }
});

canvas.addEventListener('mouseup', ()=>{
  if(mode === 'DRAGGING_SHAPE' || mode === 'DRAGGING_ANCHOR'){
    mode = 'IDLE';
    canvas.style.cursor = 'default';
  }
});

/* ===================== L√ìGICA E RENDER ===================== */
function getCentroid(points){
  if(!points || points.length === 0) return {x:0,y:0};
  let sx=0, sy=0;
  points.forEach(p=>{ sx+=p.x; sy+=p.y; });
  return { x: sx/points.length, y: sy/points.length };
}

function isPointInShape(pWorld, shape){
  ctx.save();
  // aplica a view (zoom/pan)
  ctx.translate(view.offsetX, view.offsetY);
  ctx.scale(view.scale, view.scale);

  ctx.beginPath();

  const center = getCentroid(shape.points);
  const pivotX = center.x + shape.tx + shape.anchor.x;
  const pivotY = center.y + shape.ty + shape.anchor.y;

  ctx.translate(pivotX, pivotY);
  ctx.rotate(shape.rotation * Math.PI / 180);
  ctx.scale(shape.scale, shape.scale);
  ctx.translate(-pivotX, -pivotY);
  ctx.translate(shape.tx, shape.ty);

  ctx.moveTo(shape.points[0].x, shape.points[0].y);
  for(let i=1;i<shape.points.length;i++) ctx.lineTo(shape.points[i].x, shape.points[i].y);
  ctx.closePath();

  // como o path est√° em mundo+view, precisamos passar ponto em tela?
  // mais f√°cil: converter world->screen e testar no path "da tela"
  // MAS aqui j√° aplicamos a view, ent√£o o path est√° em tela.
  const pScreen = worldToScreen(pWorld.x, pWorld.y);
  const yes = ctx.isPointInPath(pScreen.x, pScreen.y);

  ctx.restore();
  return yes;
}

function toggleReflect(axis){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  if(axis === 'x') s.reflectX = !s.reflectX;
  if(axis === 'y') s.reflectY = !s.reflectY;
  updateUI();
  draw();
}

function resetAnchor(){
  if(activeIndex === -1) return;
  shapes[activeIndex].anchor = {x:0,y:0};
  draw();
}

function toggleAnim(type){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  s.anim[type] = !s.anim[type];
  updateUI();
  requestAnimationFrame(animateLoop);
}

function changeSpeed(type, dir){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  if(dir > 0 && s.speed[type] < 4) s.speed[type] *= 2;
  else if(dir < 0 && s.speed[type] > 0.25) s.speed[type] /= 2;
  updateUI();
}

function animateLoop(){
  let activeAnim = false;
  shapes.forEach(s=>{
    if(!s.isClosed) return;
    if(s.anim.x || s.anim.y || s.anim.rot){
      activeAnim = true;
      if(s.anim.rot) s.rotation = (s.rotation + (1*s.speed.rot)) % 360;

      if(s.anim.x){
        s.tx += (2*s.speed.trans) * s.anim.dirX;
        if(s.tx > 350 || s.tx < -350) s.anim.dirX *= -1;
      }
      if(s.anim.y){
        s.ty += (2*s.speed.trans) * s.anim.dirY;
        if(s.ty > 350 || s.ty < -350) s.anim.dirY *= -1;
      }
    }
  });

  if(activeAnim){
    draw();
    if(activeIndex !== -1) updateLabelValues();
    requestAnimationFrame(animateLoop);
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // aplica zoom/pan para tudo desenhado no canvas
  ctx.save();
  ctx.translate(view.offsetX, view.offsetY);
  ctx.scale(view.scale, view.scale);

  // eixos (no mundo)
  const cx = canvas.width/(2*view.scale) - view.offsetX/view.scale;
  const cy = canvas.height/(2*view.scale) - view.offsetY/view.scale;

  ctx.strokeStyle = '#e5e7eb';
  ctx.lineWidth = 1 / view.scale;

  ctx.beginPath(); ctx.moveTo(cx, -100000); ctx.lineTo(cx, 100000); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(-100000, cy); ctx.lineTo(100000, cy); ctx.stroke();

  shapes.forEach((shape, index)=>{
    const isSelected = (index === activeIndex);

    if(index === activeIndex && mode === 'DRAWING'){
      if(shape.points.length > 0){
        ctx.beginPath();
        ctx.moveTo(shape.points[0].x, shape.points[0].y);
        shape.points.forEach(p=>ctx.lineTo(p.x,p.y));
        ctx.lineTo(mouseWorld.x, mouseWorld.y);

        ctx.strokeStyle = shape.color;
        ctx.setLineDash([5/view.scale,5/view.scale]);
        ctx.stroke();
        ctx.setLineDash([]);

        shape.points.forEach(p=>{
          ctx.beginPath(); ctx.arc(p.x,p.y,3/view.scale,0,Math.PI*2);
          ctx.fillStyle=shape.color; ctx.fill();
        });
      }
      return;
    }

    if(!shape.isClosed) return;

    ctx.globalAlpha = isSelected ? 1.0 : 0.4;

    renderInstance(shape, 1, 1, false, isSelected);
    if(shape.reflectX) renderInstance(shape, -1, 1, true, isSelected);
    if(shape.reflectY) renderInstance(shape, 1, -1, true, isSelected);
    if(shape.reflectX && shape.reflectY) renderInstance(shape, -1, -1, true, isSelected);

    ctx.globalAlpha = 1.0;
  });

  ctx.restore();
}

function renderInstance(shape, scX, scY, isGhost, isSelected){
  const center = getCentroid(shape.points);
  ctx.save();

  const pivotX = center.x + shape.tx + shape.anchor.x;
  const pivotY = center.y + shape.ty + shape.anchor.y;

  ctx.translate(pivotX, pivotY);

  let rot = shape.rotation * Math.PI / 180;
  if(scX * scY < 0) rot *= -1;
  ctx.rotate(rot);

  const finalScaleX = shape.scale * scX;
  const finalScaleY = shape.scale * scY;
  ctx.scale(finalScaleX, finalScaleY);

  ctx.translate(-pivotX, -pivotY);
  ctx.translate(shape.tx, shape.ty);

  ctx.beginPath();
  ctx.moveTo(shape.points[0].x, shape.points[0].y);
  for(let i=1;i<shape.points.length;i++) ctx.lineTo(shape.points[i].x, shape.points[i].y);
  ctx.closePath();

  if(isGhost){
    ctx.fillStyle = "rgba(219, 39, 119, 0.10)";
    ctx.strokeStyle = "rgba(219, 39, 119, 0.65)";
    ctx.setLineDash([4/view.scale,4/view.scale]);
  } else {
    ctx.fillStyle = shape.color + "33";
    ctx.strokeStyle = shape.color;
    ctx.setLineDash([]);
  }

  ctx.lineWidth = (isSelected ? (isGhost ? 2 : 3) : 1) / view.scale;
  ctx.fill();
  ctx.stroke();

  ctx.restore();

  if(isSelected && !isGhost){
    // ponto do centro (√¢ncora)
    ctx.save();
    const aX = pivotX;
    const aY = pivotY;
    ctx.beginPath();
    ctx.arc(aX, aY, 5/view.scale, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(245,158,11,1)';
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2 / view.scale;
    ctx.stroke();
    ctx.restore();
  }
}
</script>
</body>
</html>
