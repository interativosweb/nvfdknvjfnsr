<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GeoLab Pro - Laborat√≥rio de Geometria</title>
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #ec4899;
      --accent: #f59e0b;
      --success: #10b981;
      --danger: #ef4444;
      --bg-dark: #0f172a;
      --bg-panel: rgba(30, 41, 59, 0.7);
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --border: rgba(255, 255, 255, 0.1);
      --glass: rgba(255, 255, 255, 0.05);
      --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #312e81 100%);
      background-attachment: fixed;
      color: var(--text-primary);
      height: 100vh;
      display: flex;
      overflow: hidden;
      position: relative;
    }

    /* Efeito de fundo animado */
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                  radial-gradient(circle at 80% 20%, rgba(236, 72, 153, 0.1) 0%, transparent 40%),
                  radial-gradient(circle at 20% 80%, rgba(245, 158, 11, 0.1) 0%, transparent 40%);
      animation: gradientMove 20s ease infinite;
      z-index: -1;
      pointer-events: none;
    }

    @keyframes gradientMove {
      0%, 100% { transform: translate(0, 0) rotate(0deg); }
      33% { transform: translate(2%, 2%) rotate(120deg); }
      66% { transform: translate(-1%, 1%) rotate(240deg); }
    }

    /* Sidebar Esquerda - Glassmorphism */
    .sidebar-left {
      width: 320px;
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      z-index: 20;
      box-shadow: var(--shadow);
      transition: transform 0.3s ease;
    }

    .header-box {
      padding: 24px;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(236, 72, 153, 0.1) 100%);
      border-bottom: 1px solid var(--border);
      position: relative;
      overflow: hidden;
    }

    .header-box::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
      100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
    }

    h1 {
      font-size: 1.6rem;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 0;
      font-weight: 800;
      letter-spacing: -0.5px;
    }

    .subtitle {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 4px;
      font-weight: 500;
    }

    .scroll-area {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      scrollbar-width: thin;
      scrollbar-color: var(--primary) transparent;
    }

    .scroll-area::-webkit-scrollbar {
      width: 6px;
    }

    .scroll-area::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 3px;
    }

    h2 {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      padding-bottom: 8px;
      margin: 20px 0 12px 0;
      font-weight: 700;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h2::before {
      content: '';
      width: 4px;
      height: 16px;
      background: var(--primary);
      border-radius: 2px;
    }

    .control-group {
      background: var(--glass);
      padding: 16px;
      border-radius: 16px;
      border: 1px solid var(--border);
      margin-bottom: 16px;
      transition: all 0.3s ease;
    }

    .control-group:hover {
      border-color: rgba(99, 102, 241, 0.3);
      box-shadow: 0 4px 20px rgba(99, 102, 241, 0.1);
    }

    /* Bot√µes modernos com efeito de brilho */
    button {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 0.85rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      background: var(--glass);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      border-color: rgba(255,255,255,0.2);
    }

    button:active {
      transform: translateY(0) scale(0.98);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      border: none;
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
    }

    .btn-primary:hover {
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.6);
    }

    .btn-danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      border: none;
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
      border: none;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
    }

    .btn-anim {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      border: none;
    }

    .btn-anim.active {
      background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
    }

    .btn-toggle {
      background: var(--glass);
      border: 1px solid var(--border);
    }

    .btn-toggle.active {
      background: linear-gradient(135deg, var(--secondary) 0%, #db2777 100%);
      border-color: transparent;
      box-shadow: 0 4px 15px rgba(236, 72, 153, 0.4);
    }

    .btn-tool {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      font-size: 0.8rem;
    }

    .btn-tool .icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      font-size: 1rem;
    }

    input[type=range] {
      width: 100%;
      margin: 12px 0;
      -webkit-appearance: none;
      background: transparent;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(99, 102, 241, 0.5);
      border: 2px solid white;
      margin-top: -7px;
    }

    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
    }

    label {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-weight: 500;
      margin-bottom: 4px;
    }

    .value-display {
      color: var(--primary);
      font-weight: 700;
      font-family: 'Courier New', monospace;
    }

    /* Menu Flutuante de Camadas */
    .floating-layers {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 220px;
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 16px;
      box-shadow: var(--shadow);
      z-index: 30;
      max-height: 80vh;
      overflow-y: auto;
    }

    .layer-item {
      padding: 12px;
      margin-bottom: 8px;
      background: var(--glass);
      border: 1px solid transparent;
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .layer-item:hover {
      background: rgba(99, 102, 241, 0.1);
      transform: translateX(-4px);
    }

    .layer-item.active {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(236, 72, 153, 0.1) 100%);
      border-color: var(--primary);
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2);
    }

    .layer-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      transition: all 0.3s;
    }

    .layer-item.active .layer-status {
      background: var(--primary);
      box-shadow: 0 0 10px var(--primary);
    }

    .speed-control {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px;
      background: rgba(0,0,0,0.2);
      padding: 8px;
      border-radius: 10px;
    }

    .speed-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      margin: 0;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      font-weight: 700;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .speed-btn:hover {
      background: var(--primary);
    }

    .speed-txt {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-secondary);
    }

    /* Canvas Principal */
    .main-content {
      flex: 1;
      position: relative;
      background-image:
        linear-gradient(rgba(99, 102, 241, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(99, 102, 241, 0.03) 1px, transparent 1px);
      background-size: 40px 40px;
      overflow: hidden;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .instruction {
      position: absolute;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      padding: 12px 24px;
      border-radius: 50px;
      box-shadow: var(--shadow);
      font-weight: 600;
      color: var(--text-primary);
      pointer-events: none;
      border: 1px solid var(--border);
      font-size: 0.9rem;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 10px;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(-5px); }
    }

    .instruction::before {
      content: 'üí°';
    }

    .footer {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-align: center;
      padding: 16px;
      border-top: 1px solid var(--border);
      background: rgba(0,0,0,0.2);
    }

    /* Barra Inferior de Ferramentas */
    .bottom-toolbar {
      position: absolute;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      z-index: 25;
      user-select: none;
    }

    .geo-main-btn {
      width: auto;
      padding: 16px 24px;
      border-radius: 50px;
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: var(--shadow);
      font-weight: 700;
      font-size: 0.95rem;
      color: var(--text-primary);
    }

    .geo-main-btn .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      box-shadow: 0 0 15px var(--primary);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.8; }
    }

    .geo-main-btn .chev {
      margin-left: 8px;
      transition: transform 0.3s ease;
      font-size: 0.8rem;
    }

    .bottom-toolbar.open .geo-main-btn .chev {
      transform: rotate(180deg);
    }

    .geo-menu {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 80px;
      width: 280px;
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 8px;
      max-height: 60vh;
      overflow-y: auto;
      animation: slideUp 0.3s ease;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    .bottom-toolbar.open .geo-menu {
      display: flex;
    }

    .geo-item {
      width: 100%;
      background: var(--glass);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-radius: 16px;
      padding: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 0;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .geo-item:hover {
      background: rgba(99, 102, 241, 0.1);
      border-color: var(--primary);
      transform: translateX(5px);
    }

    .geo-item .left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .geo-icon {
      width: 36px;
      height: 36px;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(236, 72, 153, 0.1) 100%);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
    }

    .geo-item small {
      opacity: 0.6;
      font-weight: 700;
      font-size: 0.7rem;
      background: rgba(255,255,255,0.1);
      padding: 4px 8px;
      border-radius: 6px;
    }

    /* Grid de ferramentas r√°pidas */
    .quick-tools {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 12px;
    }

    .tool-category {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-secondary);
      margin: 16px 0 8px 0;
      font-weight: 700;
    }

    /* Empty state melhorado */
    #emptyStateMsg {
      text-align: center;
      color: var(--text-secondary);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
      padding: 40px;
    }

    .empty-icon {
      font-size: 4rem;
      margin-bottom: 16px;
      opacity: 0.5;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 0.75rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 100;
    }

    /* Responsividade */
    @media (max-width: 768px) {
      .sidebar-left {
        position: absolute;
        transform: translateX(-100%);
        height: 100%;
      }
      .sidebar-left.open {
        transform: translateX(0);
      }
      .floating-layers {
        width: 180px;
        right: 10px;
        top: 10px;
      }
    }
  </style>
</head>

<body>
  <aside class="sidebar-left">
    <div class="header-box">
      <h1>üìê GeoLab Pro</h1>
      <p class="subtitle">Laborat√≥rio de Geometria Anal√≠tica</p>
    </div>

    <div class="scroll-area" id="controlsPanel" style="display:none">
      <!-- Ferramentas de Desenho -->
      <div class="tool-category">Ferramentas de Desenho</div>
      <div class="control-group">
        <button class="btn-tool" onclick="setTool('point')">
          <span class="icon">‚Ä¢</span> Ponto
        </button>
        <button class="btn-tool" onclick="setTool('segment')">
          <span class="icon">‚îÅ</span> Segmento de Reta
        </button>
        <button class="btn-tool" onclick="setTool('line')">
          <span class="icon">‚Üî</span> Reta (Infinita)
        </button>
        <button class="btn-tool" onclick="setTool('polygon')">
          <span class="icon">‚¨°</span> Pol√≠gono Livre
        </button>
      </div>

      <div class="control-group" style="border-left: 3px solid var(--accent);">
        <h2 style="margin-top:0; color:var(--accent);">Centro da Figura</h2>
        <p style="font-size:0.75rem; color:var(--text-secondary); margin-bottom:12px;">
          Arraste o ponto laranja para mover o eixo de rota√ß√£o.
        </p>
        <button class="btn-toggle" onclick="resetAnchor()" style="font-size:0.8rem">
          üéØ Resetar Centro
        </button>
      </div>

      <div class="control-group">
        <h2>Transla√ß√£o</h2>
        <label>X: <span id="valTx" class="value-display">0</span></label>
        <input type="range" id="inputTx" min="-500" max="500" value="0" oninput="updateShapeData()">
        <button class="btn-anim" id="animXBtn" onclick="toggleAnim('x')">
          <span>‚ñ∂</span> Animar X
        </button>

        <label style="margin-top:12px;">Y: <span id="valTy" class="value-display">0</span></label>
        <input type="range" id="inputTy" min="-500" max="500" value="0" oninput="updateShapeData()">
        <button class="btn-anim" id="animYBtn" onclick="toggleAnim('y')">
          <span>‚ñ∂</span> Animar Y
        </button>

        <div class="speed-control">
          <button class="speed-btn" onclick="changeSpeed('trans', -1)">‚àí</button>
          <span class="speed-txt">Velocidade: <span id="speedTransDisplay" class="value-display">1x</span></span>
          <button class="speed-btn" onclick="changeSpeed('trans', 1)">+</button>
        </div>
      </div>

      <div class="control-group">
        <h2>Rota√ß√£o</h2>
        <label>√Çngulo: <span id="valRot" class="value-display">0¬∞</span></label>
        <input type="range" id="inputRot" min="0" max="360" value="0" oninput="updateShapeData()">
        <button class="btn-anim" id="animRotBtn" onclick="toggleAnim('rot')">
          <span>‚ñ∂</span> Animar Rota√ß√£o
        </button>

        <div class="speed-control">
          <button class="speed-btn" onclick="changeSpeed('rot', -1)">‚àí</button>
          <span class="speed-txt">Velocidade: <span id="speedRotDisplay" class="value-display">1x</span></span>
          <button class="speed-btn" onclick="changeSpeed('rot', 1)">+</button>
        </div>
      </div>

      <div class="control-group">
        <h2>Escala</h2>
        <label>Escala: <span id="valScale" class="value-display">100%</span></label>
        <input type="range" id="inputScale" min="10" max="300" value="100" oninput="updateShapeData()">
        <button class="btn-toggle" onclick="resetScale()">‚Ü∫ Resetar Tamanho</button>
      </div>

      <div class="control-group">
        <h2>Simetria (Espelho)</h2>
        <div class="quick-tools">
          <button id="btnRefX" class="btn-toggle" onclick="toggleReflect('x')">‚Üî Espelho X</button>
          <button id="btnRefY" class="btn-toggle" onclick="toggleReflect('y')">‚Üï Espelho Y</button>
        </div>
      </div>

      <button class="btn-danger" onclick="deleteCurrentLayer()" style="margin-top:16px;">
        üóëÔ∏è Excluir Figura
      </button>
    </div>

    <div class="scroll-area" id="emptyStateMsg">
      <div class="empty-icon">üìê</div>
      <p>Nenhuma figura selecionada.</p>
      <p style="font-size:0.75rem; margin-top:8px; opacity:0.6;">
        Clique em "+ Nova Figura" para come√ßar
      </p>
    </div>

    <div class="footer">
      Desenvolvido por Gilberto Fernandes<br>
      <span style="opacity:0.6;">Matem√°tica & Computa√ß√£o Gr√°fica</span>
    </div>
  </aside>

  <main class="main-content" id="mainArea">
    <div class="instruction" id="instructionText">
      Clique em "+ Nova Figura" para come√ßar
    </div>
    <canvas id="canvas"></canvas>
    <div class="tooltip" id="tooltip"></div>

    <!-- Barra inferior de ferramentas -->
    <div class="bottom-toolbar" id="bottomToolbar">
      <button class="geo-main-btn" id="geoMainBtn" type="button">
        <span class="dot"></span>
        <span>Figuras Geom√©tricas</span>
        <span class="chev">‚ñº</span>
      </button>

      <div class="geo-menu" id="geoMenu">
        <div class="tool-category">Formas B√°sicas</div>
        <button class="geo-item" onclick="addPresetShape('point')">
          <span class="left"><span class="geo-icon">‚Ä¢</span> Ponto</span><small>0D</small>
        </button>
        <button class="geo-item" onclick="addPresetShape('segment')">
          <span class="left"><span class="geo-icon">‚îÅ</span> Segmento</span><small>1D</small>
        </button>
        <button class="geo-item" onclick="addPresetShape('line')">
          <span class="left"><span class="geo-icon">‚Üî</span> Reta</span><small>1D</small>
        </button>
        <button class="geo-item" onclick="addPresetShape('circle')">
          <span class="left"><span class="geo-icon">‚óØ</span> C√≠rculo</span><small>2D</small>
        </button>
        
        <div class="tool-category">Pol√≠gonos</div>
        <button class="geo-item" onclick="addPresetShape('triangle')">
          <span class="left"><span class="geo-icon">‚ñ≥</span> Tri√¢ngulo</span><small>2D</small>
        </button>
        <button class="geo-item" onclick="addPresetShape('square')">
          <span class="left"><span class="geo-icon">‚ñ¢</span> Quadrado</span><small>2D</small>
        </button>
        <button class="geo-item" onclick="addPresetShape('rect')">
          <span class="left"><span class="geo-icon">‚ñ≠</span> Ret√¢ngulo</span><small>2D</small>
        </button>
        <button class="geo-item" onclick="addPresetShape('pent')">
          <span class="left"><span class="geo-icon">‚¨†</span> Pent√°gono</span><small>2D</small>
        </button>
        <button class="geo-item" onclick="addPresetShape('hex')">
          <span class="left"><span class="geo-icon">‚¨°</span> Hex√°gono</span><small>2D</small>
        </button>
      </div>
    </div>
  </main>

  <div class="floating-layers">
    <button class="btn-success" onclick="createNewLayer()" style="margin-bottom:12px; width:100%; padding:14px; font-size:0.9rem;">
      + Nova Figura
    </button>
    <div id="layersList"></div>
  </div>

<script>
/* =========================================================
   PROTE√á√ÉO B√ÅSICA
========================================================= */
(function hardenPage(){
  document.addEventListener('contextmenu', (e)=>e.preventDefault(), {capture:true});
  document.addEventListener('dragstart', (e)=>e.preventDefault(), {capture:true});
  document.addEventListener('selectstart', (e)=>{
    const tag = e.target?.tagName?.toLowerCase?.() || '';
    if(tag === 'input' || tag === 'textarea') return;
    e.preventDefault();
  }, {capture:true});
})();

/* =========================================================
   APP GEOLAB PRO
========================================================= */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const mainArea = document.getElementById('mainArea');
const tooltip = document.getElementById('tooltip');

let shapes = [];
let activeIndex = -1;
let mode = 'IDLE'; // IDLE, DRAWING, DRAGGING_ANCHOR, DRAGGING_SHAPE
let currentTool = 'polygon'; // polygon, point, segment, line
let mouseScreen = { x: 0, y: 0 };
let mouseWorld = { x: 0, y: 0 };
let dragStartWorld = { x: 0, y: 0 };

// View (Zoom e Pan)
let view = {
  scale: 1.0,
  offsetX: 0,
  offsetY: 0,
  minScale: 0.2,
  maxScale: 5.0
};

const colors = ['#6366f1', '#ec4899', '#f59e0b', '#10b981', '#8b5cf6', '#06b6d4', '#f97316'];

// Tipos de forma
const SHAPE_TYPES = {
  POINT: 'point',
  SEGMENT: 'segment',
  LINE: 'line',
  POLYGON: 'polygon',
  CIRCLE: 'circle'
};

function resizeCanvas(){
  canvas.width = mainArea.clientWidth;
  canvas.height = mainArea.clientHeight;
  if (view.offsetX === 0 && view.offsetY === 0) {
    view.offsetX = canvas.width / 2;
    view.offsetY = canvas.height / 2;
  }
  draw();
}
window.addEventListener('resize', resizeCanvas);
setTimeout(resizeCanvas, 100);

/* ===================== MENU INFERIOR ===================== */
const bottomToolbar = document.getElementById('bottomToolbar');
const geoMainBtn = document.getElementById('geoMainBtn');

function toggleGeoMenu(){
  bottomToolbar.classList.toggle('open');
}
geoMainBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  toggleGeoMenu();
});
document.addEventListener('click', ()=>{
  bottomToolbar.classList.remove('open');
});
document.getElementById('geoMenu').addEventListener('click', (e)=>e.stopPropagation());

/* ===================== COORDENADAS ===================== */
function screenToWorld(x, y){
  return {
    x: (x - view.offsetX) / view.scale,
    y: (y - view.offsetY) / view.scale
  };
}
function worldToScreen(x, y){
  return {
    x: x * view.scale + view.offsetX,
    y: y * view.scale + view.offsetY
  };
}

/* ===================== ZOOM COM SCROLL ===================== */
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const before = screenToWorld(sx, sy);
  
  const zoomIn = e.deltaY < 0;
  const factor = zoomIn ? 1.15 : 0.85;
  const newScale = Math.max(view.minScale, Math.min(view.maxScale, view.scale * factor));
  view.scale = newScale;
  
  view.offsetX = sx - before.x * view.scale;
  view.offsetY = sy - before.y * view.scale;
  
  mouseScreen = {x: sx, y: sy};
  mouseWorld = screenToWorld(sx, sy);
  draw();
}, { passive: false });

/* ===================== GERENCIAMENTO DE CAMADAS ===================== */
function createNewLayer(){
  const newShape = {
    id: Date.now(),
    name: `Figura ${shapes.length + 1}`,
    type: SHAPE_TYPES.POLYGON,
    points: [],
    color: colors[shapes.length % colors.length],
    isClosed: false,
    tx: 0, ty: 0, rotation: 0,
    scale: 1.0,
    reflectX: false, reflectY: false,
    anchor: { x: 0, y: 0 },
    anim: { x: false, y: false, rot: false, dirX: 1, dirY: 1 },
    speed: { trans: 1.0, rot: 1.0 },
    // Propriedades espec√≠ficas
    pointRadius: 5, // Para pontos
    lineLength: 1000, // Para retas infinitas (tamanho visual)
    showExtension: true // Mostrar extens√£o da reta
  };

  shapes.push(newShape);
  selectLayer(shapes.length - 1);
  currentTool = 'polygon';
  mode = 'DRAWING';
  updateUI();
  showInstruction(`Criando ${newShape.name}: Clique para adicionar v√©rtices. Clique no primeiro ponto para fechar.`);
}

function selectLayer(index){
  if(index < 0 || index >= shapes.length){
    activeIndex = -1;
    mode = 'IDLE';
  } else {
    if(activeIndex !== -1 && !shapes[activeIndex].isClosed && shapes[activeIndex].type !== SHAPE_TYPES.POINT){
      alert("Feche a forma atual antes de trocar.");
      return;
    }
    activeIndex = index;
    const shape = shapes[index];
    mode = shape.isClosed ? 'IDLE' : 'DRAWING';
    currentTool = shape.type === SHAPE_TYPES.POLYGON && !shape.isClosed ? 'polygon' : shape.type;
  }
  updateUI();
  draw();
}

function deleteCurrentLayer(){
  if(activeIndex === -1) return;
  shapes.splice(activeIndex, 1);
  activeIndex = -1;
  mode = 'IDLE';
  updateUI();
  draw();
}

function updateUI(){
  const layersList = document.getElementById('layersList');
  layersList.innerHTML = '';

  shapes.forEach((shape, idx)=>{
    const div = document.createElement('div');
    div.className = `layer-item ${idx === activeIndex ? 'active' : ''}`;
    div.onclick = ()=>selectLayer(idx);
    
    const icon = getShapeIcon(shape.type);
    div.innerHTML = `
      <span style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:1.1rem;">${icon}</span>
        ${shape.name}
      </span>
      <div class="layer-status"></div>
    `;
    layersList.appendChild(div);
  });

  const controls = document.getElementById('controlsPanel');
  const emptyMsg = document.getElementById('emptyStateMsg');

  if(activeIndex !== -1 && shapes[activeIndex].isClosed){
    controls.style.display = 'block';
    emptyMsg.style.display = 'none';

    const s = shapes[activeIndex];
    document.getElementById('inputTx').value = s.tx;
    document.getElementById('inputTy').value = s.ty;
    document.getElementById('inputRot').value = s.rotation;
    document.getElementById('inputScale').value = Math.round(s.scale * 100);

    document.getElementById('btnRefX').classList.toggle('active', s.reflectX);
    document.getElementById('btnRefY').classList.toggle('active', s.reflectY);

    document.getElementById('animXBtn').classList.toggle('active', s.anim.x);
    document.getElementById('animYBtn').classList.toggle('active', s.anim.y);
    document.getElementById('animRotBtn').classList.toggle('active', s.anim.rot);

    hideInstruction();
  } else {
    controls.style.display = 'none';
    emptyMsg.style.display = 'flex';
  }
  updateLabelValues();
}

function getShapeIcon(type){
  const icons = {
    [SHAPE_TYPES.POINT]: '‚Ä¢',
    [SHAPE_TYPES.SEGMENT]: '‚îÅ',
    [SHAPE_TYPES.LINE]: '‚Üî',
    [SHAPE_TYPES.POLYGON]: '‚¨°',
    [SHAPE_TYPES.CIRCLE]: '‚óØ'
  };
  return icons[type] || '‚¨°';
}

function showInstruction(text){
  const el = document.getElementById('instructionText');
  el.style.display = 'flex';
  el.innerText = text;
}

function hideInstruction(){
  document.getElementById('instructionText').style.display = 'none';
}

/* ===================== ATUALIZA√á√ÉO DE DADOS ===================== */
function updateShapeData(){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];

  s.tx = parseInt(document.getElementById('inputTx').value);
  s.ty = -parseInt(document.getElementById('inputTy').value); // Y invertido para conven√ß√£o matem√°tica
  s.rotation = parseInt(document.getElementById('inputRot').value);

  const sc = parseInt(document.getElementById('inputScale').value);
  s.scale = Math.max(0.10, Math.min(3.00, sc / 100));

  updateLabelValues();
  draw();
}

function updateLabelValues(){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  document.getElementById('valTx').innerText = s.tx;
  document.getElementById('valTy').innerText = -s.ty; // Mostra positivo para cima
  document.getElementById('valRot').innerText = s.rotation + "¬∞";
  document.getElementById('valScale').innerText = Math.round(s.scale * 100) + "%";
  document.getElementById('speedTransDisplay').innerText = s.speed.trans + "x";
  document.getElementById('speedRotDisplay').innerText = s.speed.rot + "x";
}

function resetScale(){
  if(activeIndex === -1) return;
  shapes[activeIndex].scale = 1.0;
  document.getElementById('inputScale').value = 100;
  updateLabelValues();
  draw();
}

/* ===================== FERRAMENTAS DE DESENHO ===================== */
function setTool(tool){
  currentTool = tool;
  if(activeIndex !== -1){
    const s = shapes[activeIndex];
    s.type = tool;
    s.isClosed = false;
    
    if(tool === SHAPE_TYPES.POINT){
      s.isClosed = true;
      s.points = [{x: 0, y: 0}];
      mode = 'IDLE';
      updateUI();
    } else if(tool === SHAPE_TYPES.SEGMENT || tool === SHAPE_TYPES.LINE){
      s.points = [];
      mode = 'DRAWING';
      showInstruction(`Modo ${tool === 'segment' ? 'Segmento' : 'Reta'}: Clique no ponto inicial e final.`);
    }
    draw();
  }
}

/* ===================== FIGURAS PREDEFINIDAS ===================== */
function addPresetShape(type){
  bottomToolbar.classList.remove('open');

  if(activeIndex !== -1 && !shapes[activeIndex].isClosed){
    alert("Feche a forma atual antes de inserir uma nova figura.");
    return;
  }

  const worldCenter = screenToWorld(canvas.width/2, canvas.height/2);
  const cx = worldCenter.x;
  const cy = worldCenter.y;
  const size = 120;

  let newShape = {
    id: Date.now(),
    name: `Figura ${shapes.length + 1}`,
    type: type,
    color: colors[shapes.length % colors.length],
    isClosed: true,
    tx: 0, ty: 0, rotation: 0,
    scale: 1.0,
    reflectX: false, reflectY: false,
    anchor: { x: 0, y: 0 },
    anim: { x: false, y: false, rot: false, dirX: 1, dirY: 1 },
    speed: { trans: 1.0, rot: 1.0 },
    pointRadius: 6,
    lineLength: 1000,
    showExtension: true
  };

  switch(type){
    case SHAPE_TYPES.POINT:
      newShape.points = [{x: cx, y: cy}];
      newShape.isClosed = true;
      break;
      
    case SHAPE_TYPES.SEGMENT:
      newShape.points = [
        {x: cx - size/2, y: cy},
        {x: cx + size/2, y: cy}
      ];
      newShape.isClosed = true;
      break;
      
    case SHAPE_TYPES.LINE:
      newShape.points = [
        {x: cx - size, y: cy},
        {x: cx + size, y: cy}
      ];
      newShape.isClosed = true;
      newShape.showExtension = true;
      break;
      
    case 'square':
      newShape.type = SHAPE_TYPES.POLYGON;
      newShape.points = [
        {x: cx-size/2, y: cy-size/2},
        {x: cx+size/2, y: cy-size/2},
        {x: cx+size/2, y: cy+size/2},
        {x: cx-size/2, y: cy+size/2}
      ];
      break;
      
    case 'rect':
      newShape.type = SHAPE_TYPES.POLYGON;
      const w = size * 1.4, h = size * 0.8;
      newShape.points = [
        {x: cx-w/2, y: cy-h/2},
        {x: cx+w/2, y: cy-h/2},
        {x: cx+w/2, y: cy+h/2},
        {x: cx-w/2, y: cy+h/2}
      ];
      break;
      
    case 'triangle':
      newShape.type = SHAPE_TYPES.POLYGON;
      newShape.points = [
        {x: cx, y: cy - size/2},
        {x: cx + size/2, y: cy + size/2},
        {x: cx - size/2, y: cy + size/2}
      ];
      break;
      
    case 'circle':
      newShape.type = SHAPE_TYPES.CIRCLE;
      newShape.points = [{x: cx, y: cy}];
      newShape.radius = size/2;
      break;
      
    case 'pent':
      newShape.type = SHAPE_TYPES.POLYGON;
      newShape.points = regularPolygonPoints(cx, cy, size/2, 5, -Math.PI/2);
      break;
      
    case 'hex':
      newShape.type = SHAPE_TYPES.POLYGON;
      newShape.points = regularPolygonPoints(cx, cy, size/2, 6, -Math.PI/2);
      break;
  }

  shapes.push(newShape);
  selectLayer(shapes.length - 1);
  mode = 'IDLE';
  updateUI();
  draw();
}

function regularPolygonPoints(cx, cy, r, n, offset){
  const pts = [];
  for(let i=0; i<n; i++){
    const a = offset + (i/n) * Math.PI * 2;
    pts.push({x: cx + Math.cos(a)*r, y: cy + Math.sin(a)*r});
  }
  return pts;
}

/* ===================== INTERA√á√ÉO DO MOUSE ===================== */
canvas.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  mouseScreen.x = e.clientX - rect.left;
  mouseScreen.y = e.clientY - rect.top;
  mouseWorld = screenToWorld(mouseScreen.x, mouseScreen.y);
  
  // Tooltip
  updateTooltip(e.clientX, e.clientY);

  if(mode === 'DRAWING' && activeIndex !== -1){
    const s = shapes[activeIndex];
    
    if(s.type === SHAPE_TYPES.POLYGON && s.points.length >= 3){
      const dx = mouseWorld.x - s.points[0].x;
      const dy = mouseWorld.y - s.points[0].y;
      if(Math.hypot(dx,dy) < 15/view.scale){
        canvas.style.cursor = 'pointer';
        showInstruction("Clique no primeiro ponto para fechar o pol√≠gono!");
      } else {
        canvas.style.cursor = 'crosshair';
      }
    }
    draw();
    return;
  }

  if(mode === 'DRAGGING_ANCHOR'){
    const s = shapes[activeIndex];
    const center = getCentroid(s);
    s.anchor.x = mouseWorld.x - (center.x + s.tx);
    s.anchor.y = mouseWorld.y - (center.y + s.ty);
    draw();
    return;
  }

  if(mode === 'DRAGGING_SHAPE'){
    const dx = mouseWorld.x - dragStartWorld.x;
    const dy = mouseWorld.y - dragStartWorld.y;
    const s = shapes[activeIndex];
    s.tx += dx;
    s.ty += dy;
    document.getElementById('inputTx').value = Math.round(s.tx);
    document.getElementById('inputTy').value = Math.round(-s.ty);
    updateLabelValues();
    dragStartWorld = { x: mouseWorld.x, y: mouseWorld.y };
    draw();
    return;
  }

  // Detec√ß√£o de hover
  let cursor = 'default';
  if(activeIndex !== -1){
    const s = shapes[activeIndex];
    const center = getCentroid(s);
    const anchorX = center.x + s.tx + s.anchor.x;
    const anchorY = center.y + s.ty + s.anchor.y;
    
    if(Math.hypot(mouseWorld.x - anchorX, mouseWorld.y - anchorY) < 12/view.scale){
      cursor = 'move';
      showTooltip(mouseScreen.x, mouseScreen.y, "Arraste para mover o centro de rota√ß√£o");
    } else if(isPointInShape(mouseWorld, s)){
      cursor = 'grab';
      showTooltip(mouseScreen.x, mouseScreen.y, "Arraste para mover a figura");
    }
  } else {
    for(let i=shapes.length-1; i>=0; i--){
      if(shapes[i].isClosed && isPointInShape(mouseWorld, shapes[i])){
        cursor = 'pointer';
        break;
      }
    }
  }
  canvas.style.cursor = cursor;
});

canvas.addEventListener('mousedown', ()=>{
  if(mode === 'DRAWING' && activeIndex !== -1){
    const s = shapes[activeIndex];
    
    // Fechar pol√≠gono
    if(s.type === SHAPE_TYPES.POLYGON && s.points.length >= 3){
      const dx = mouseWorld.x - s.points[0].x;
      const dy = mouseWorld.y - s.points[0].y;
      if(Math.hypot(dx,dy) < 15/view.scale){
        s.isClosed = true;
        mode = 'IDLE';
        updateUI();
        draw();
        return;
      }
    }
    
    // Adicionar ponto
    s.points.push({x: mouseWorld.x, y: mouseWorld.y});
    
    // Segmento e Linha s√≥ precisam de 2 pontos
    if((s.type === SHAPE_TYPES.SEGMENT || s.type === SHAPE_TYPES.LINE) && s.points.length === 2){
      s.isClosed = true;
      mode = 'IDLE';
      updateUI();
    }
    
    draw();
    return;
  }

  // Verificar clique na √¢ncora
  if(activeIndex !== -1){
    const s = shapes[activeIndex];
    const center = getCentroid(s);
    const anchorX = center.x + s.tx + s.anchor.x;
    const anchorY = center.y + s.ty + s.anchor.y;
    
    if(Math.hypot(mouseWorld.x - anchorX, mouseWorld.y - anchorY) < 12/view.scale){
      mode = 'DRAGGING_ANCHOR';
      return;
    }
  }

  // Selecionar forma
  let clickedIndex = -1;
  if(activeIndex !== -1 && isPointInShape(mouseWorld, shapes[activeIndex])){
    clickedIndex = activeIndex;
  } else {
    for(let i=shapes.length-1; i>=0; i--){
      if(shapes[i].isClosed && isPointInShape(mouseWorld, shapes[i])){
        clickedIndex = i;
        break;
      }
    }
  }

  if(clickedIndex !== -1){
    selectLayer(clickedIndex);
    mode = 'DRAGGING_SHAPE';
    dragStartWorld = { x: mouseWorld.x, y: mouseWorld.y };
    canvas.style.cursor = 'grabbing';
  }
});

canvas.addEventListener('mouseup', ()=>{
  if(mode === 'DRAGGING_SHAPE' || mode === 'DRAGGING_ANCHOR'){
    mode = 'IDLE';
    canvas.style.cursor = 'default';
  }
});

canvas.addEventListener('mouseleave', ()=>{
  tooltip.style.opacity = '0';
});

function showTooltip(x, y, text){
  tooltip.innerText = text;
  tooltip.style.left = (x + 15) + 'px';
  tooltip.style.top = (y + 15) + 'px';
  tooltip.style.opacity = '1';
}

function updateTooltip(x, y){
  if(mode !== 'IDLE') return;
  // L√≥gica de tooltip j√° est√° no mousemove
}

/* ===================== L√ìGICA E RENDERIZA√á√ÉO ===================== */
function getCentroid(shape){
  if(!shape.points || shape.points.length === 0) return {x:0, y:0};
  
  if(shape.type === SHAPE_TYPES.CIRCLE){
    return {
      x: shape.points[0].x + shape.tx,
      y: shape.points[0].y + shape.ty
    };
  }
  
  let sx = 0, sy = 0;
  shape.points.forEach(p => { sx += p.x; sy += p.y; });
  return { x: sx/shape.points.length, y: sy/shape.points.length };
}

function isPointInShape(pWorld, shape){
  if(!shape.isClosed) return false;
  
  // Para pontos, verificar dist√¢ncia
  if(shape.type === SHAPE_TYPES.POINT){
    const p = shape.points[0];
    const dx = pWorld.x - (p.x + shape.tx);
    const dy = pWorld.y - (p.y + shape.ty);
    return Math.hypot(dx, dy) < (shape.pointRadius * shape.scale + 5)/view.scale;
  }
  
  // Para segmentos e retas, verificar proximidade da linha
  if(shape.type === SHAPE_TYPES.SEGMENT || shape.type === SHAPE_TYPES.LINE){
    return isPointNearLine(pWorld, shape);
  }
  
  // Para c√≠rculos
  if(shape.type === SHAPE_TYPES.CIRCLE){
    const center = shape.points[0];
    const dx = pWorld.x - (center.x + shape.tx);
    const dy = pWorld.y - (center.y + shape.ty);
    const dist = Math.hypot(dx, dy);
    return Math.abs(dist - shape.radius * shape.scale) < 10/view.scale;
  }

  // Para pol√≠gonos, usar ray casting
  ctx.save();
  ctx.translate(view.offsetX, view.offsetY);
  ctx.scale(view.scale, view.scale);
  
  applyTransform(ctx, shape);
  
  ctx.beginPath();
  ctx.moveTo(shape.points[0].x, shape.points[0].y);
  for(let i=1; i<shape.points.length; i++) ctx.lineTo(shape.points[i].x, shape.points[i].y);
  ctx.closePath();
  
  const pScreen = worldToScreen(pWorld.x, pWorld.y);
  const yes = ctx.isPointInPath(pScreen.x, pScreen.y);
  
  ctx.restore();
  return yes;
}

function isPointNearLine(pWorld, shape){
  const p1 = shape.points[0];
  const p2 = shape.points[1];
  
  // Transformar pontos
  const center = getCentroid(shape);
  const pivotX = center.x + shape.anchor.x;
  const pivotY = center.y + shape.anchor.y;
  
  // Aplicar transforma√ß√µes aos pontos da linha
  const tp1 = transformPoint(p1, shape, pivotX, pivotY);
  const tp2 = transformPoint(p2, shape, pivotX, pivotY);
  
  // Dist√¢ncia ponto-linha
  const A = pWorld.x - tp1.x;
  const B = pWorld.y - tp1.y;
  const C = tp2.x - tp1.x;
  const D = tp2.y - tp1.y;
  
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  
  if(lenSq !== 0) param = dot / lenSq;
  
  let xx, yy;
  if(param < 0){
    xx = tp1.x; yy = tp1.y;
  } else if(param > 1 && shape.type === SHAPE_TYPES.SEGMENT){
    xx = tp2.x; yy = tp2.y;
  } else {
    xx = tp1.x + param * C;
    yy = tp1.y + param * D;
  }
  
  const dx = pWorld.x - xx;
  const dy = pWorld.y - yy;
  return Math.hypot(dx, dy) < 10/view.scale;
}

function transformPoint(p, shape, pivotX, pivotY){
  // Aplicar transla√ß√£o
  let x = p.x + shape.tx;
  let y = p.y + shape.ty;
  
  // Rota√ß√£o
  const cos = Math.cos(shape.rotation * Math.PI / 180);
  const sin = Math.sin(shape.rotation * Math.PI / 180);
  const rx = cos * (x - pivotX) - sin * (y - pivotY) + pivotX;
  const ry = sin * (x - pivotX) + cos * (y - pivotY) + pivotY;
  
  // Escala
  const sx = pivotX + (rx - pivotX) * shape.scale;
  const sy = pivotY + (ry - pivotY) * shape.scale;
  
  return {x: sx, y: sy};
}

function applyTransform(ctx, shape){
  const center = getCentroid(shape);
  const pivotX = center.x + shape.tx + shape.anchor.x;
  const pivotY = center.y + shape.ty + shape.anchor.y;
  
  ctx.translate(pivotX, pivotY);
  ctx.rotate(shape.rotation * Math.PI / 180);
  ctx.scale(shape.scale, shape.scale);
  ctx.translate(-pivotX, -pivotY);
  ctx.translate(shape.tx, shape.ty);
}

/* ===================== CONTROLES ===================== */
function toggleReflect(axis){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  if(axis === 'x') s.reflectX = !s.reflectX;
  if(axis === 'y') s.reflectY = !s.reflectY;
  updateUI();
  draw();
}

function resetAnchor(){
  if(activeIndex === -1) return;
  shapes[activeIndex].anchor = {x:0, y:0};
  draw();
}

function toggleAnim(type){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  s.anim[type] = !s.anim[type];
  updateUI();
  requestAnimationFrame(animateLoop);
}

function changeSpeed(type, dir){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  if(dir > 0 && s.speed[type] < 4) s.speed[type] = Math.min(4, s.speed[type] * 2);
  else if(dir < 0 && s.speed[type] > 0.25) s.speed[type] = Math.max(0.25, s.speed[type] / 2);
  updateUI();
}

function animateLoop(){
  let activeAnim = false;
  shapes.forEach(s=>{
    if(!s.isClosed) return;
    if(s.anim.x || s.anim.y || s.anim.rot){
      activeAnim = true;
      if(s.anim.rot) s.rotation = (s.rotation + (1 * s.speed.rot)) % 360;
      
      if(s.anim.x){
        s.tx += (2 * s.speed.trans) * s.anim.dirX;
        if(s.tx > 400 || s.tx < -400) s.anim.dirX *= -1;
      }
      if(s.anim.y){
        s.ty += (2 * s.speed.trans) * s.anim.dirY;
        if(s.ty > 400 || s.ty < -400) s.anim.dirY *= -1;
      }
    }
  });
  
  if(activeAnim){
    draw();
    if(activeIndex !== -1) updateLabelValues();
    requestAnimationFrame(animateLoop);
  }
}

/* ===================== DESENHO ===================== */
function draw(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  ctx.save();
  ctx.translate(view.offsetX, view.offsetY);
  ctx.scale(view.scale, view.scale);
  
  // Eixos coordenados
  drawAxes();
  
  shapes.forEach((shape, index)=>{
    const isSelected = (index === activeIndex);
    
    if(index === activeIndex && mode === 'DRAWING'){
      drawPreview(shape);
      return;
    }
    
    if(!shape.isClosed) return;
    
    ctx.globalAlpha = isSelected ? 1.0 : 0.5;
    
    renderInstance(shape, 1, 1, false, isSelected);
    if(shape.reflectX) renderInstance(shape, -1, 1, true, isSelected);
    if(shape.reflectY) renderInstance(shape, 1, -1, true, isSelected);
    if(shape.reflectX && shape.reflectY) renderInstance(shape, -1, -1, true, isSelected);
    
    ctx.globalAlpha = 1.0;
  });
  
  ctx.restore();
}

function drawAxes(){
  const range = 2000;
  ctx.strokeStyle = 'rgba(99, 102, 241, 0.2)';
  ctx.lineWidth = 1/view.scale;
  
  // Eixo X
  ctx.beginPath();
  ctx.moveTo(-range, 0);
  ctx.lineTo(range, 0);
  ctx.stroke();
  
  // Eixo Y
  ctx.beginPath();
  ctx.moveTo(0, -range);
  ctx.lineTo(0, range);
  ctx.stroke();
  
  // Marca√ß√µes
  ctx.fillStyle = 'rgba(99, 102, 241, 0.4)';
  ctx.font = `${10/view.scale}px sans-serif`;
  for(let i = -1000; i <= 1000; i += 100){
    if(i === 0) continue;
    // Marca√ß√µes X
    ctx.fillRect(i - 2/view.scale, -2/view.scale, 4/view.scale, 4/view.scale);
    ctx.fillText(i, i + 5/view.scale, 15/view.scale);
    // Marca√ß√µes Y
    ctx.fillRect(-2/view.scale, i - 2/view.scale, 4/view.scale, 4/view.scale);
    ctx.fillText(-i, 8/view.scale, i - 5/view.scale); // Y invertido na tela
  }
  
  // Origem
  ctx.fillStyle = 'rgba(236, 72, 153, 0.6)';
  ctx.beginPath();
  ctx.arc(0, 0, 4/view.scale, 0, Math.PI*2);
  ctx.fill();
}

function drawPreview(shape){
  if(shape.points.length === 0) return;
  
  ctx.strokeStyle = shape.color;
  ctx.lineWidth = 2/view.scale;
  ctx.setLineDash([5/view.scale, 5/view.scale]);
  
  ctx.beginPath();
  ctx.moveTo(shape.points[0].x, shape.points[0].y);
  shape.points.forEach(p => ctx.lineTo(p.x, p.y));
  
  // Linha para o mouse
  if(shape.type === SHAPE_TYPES.POLYGON || 
     ((shape.type === SHAPE_TYPES.SEGMENT || shape.type === SHAPE_TYPES.LINE) && shape.points.length < 2)){
    ctx.lineTo(mouseWorld.x, mouseWorld.y);
  }
  
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Pontos
  shape.points.forEach((p, i)=>{
    ctx.beginPath();
    ctx.arc(p.x, p.y, 4/view.scale, 0, Math.PI*2);
    ctx.fillStyle = shape.color;
    ctx.fill();
    
    // Destacar primeiro ponto
    if(i === 0 && shape.type === SHAPE_TYPES.POLYGON && shape.points.length >= 3){
      ctx.beginPath();
      ctx.arc(p.x, p.y, 8/view.scale, 0, Math.PI*2);
      ctx.strokeStyle = shape.color;
      ctx.lineWidth = 2/view.scale;
      ctx.stroke();
    }
  });
}

function renderInstance(shape, scX, scY, isGhost, isSelected){
  ctx.save();
  
  const center = getCentroid(shape);
  const pivotX = center.x + shape.tx + shape.anchor.x;
  const pivotY = center.y + shape.ty + shape.anchor.y;
  
  ctx.translate(pivotX, pivotY);
  
  let rot = shape.rotation * Math.PI / 180;
  if(scX * scY < 0) rot *= -1;
  ctx.rotate(rot);
  
  ctx.scale(shape.scale * scX, shape.scale * scY);
  ctx.translate(-pivotX, -pivotY);
  ctx.translate(shape.tx, shape.ty);
  
  // Estilo
  if(isGhost){
    ctx.strokeStyle = "rgba(236, 72, 153, 0.8)";
    ctx.fillStyle = "rgba(236, 72, 153, 0.1)";
    ctx.setLineDash([4/view.scale, 4/view.scale]);
  } else {
    ctx.strokeStyle = shape.color;
    ctx.fillStyle = shape.color + "33";
    ctx.setLineDash([]);
  }
  
  ctx.lineWidth = (isSelected ? (isGhost ? 2 : 3) : 1.5) / view.scale;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  // Desenhar conforme o tipo
  switch(shape.type){
    case SHAPE_TYPES.POINT:
      drawPoint(shape, isGhost, isSelected);
      break;
    case SHAPE_TYPES.SEGMENT:
      drawSegment(shape);
      break;
    case SHAPE_TYPES.LINE:
      drawLine(shape);
      break;
    case SHAPE_TYPES.CIRCLE:
      drawCircle(shape);
      break;
    case SHAPE_TYPES.POLYGON:
      drawPolygon(shape);
      break;
  }
  
  ctx.restore();
  
  // Desenhar √¢ncora se selecionado
  if(isSelected && !isGhost && shape.type !== SHAPE_TYPES.POINT){
    drawAnchor(pivotX, pivotY);
  }
}

function drawPoint(shape, isGhost, isSelected){
  const p = shape.points[0];
  const r = shape.pointRadius / view.scale;
  
  ctx.beginPath();
  ctx.arc(p.x, p.y, r, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  
  // Brilho
  if(isSelected && !isGhost){
    ctx.beginPath();
    ctx.arc(p.x, p.y, r * 1.5, 0, Math.PI*2);
    ctx.fillStyle = shape.color + "22";
    ctx.fill();
  }
}

function drawSegment(shape){
  if(shape.points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(shape.points[0].x, shape.points[0].y);
  ctx.lineTo(shape.points[1].x, shape.points[1].y);
  ctx.stroke();
  
  // Pontos extremos
  ctx.fillStyle = shape.color;
  shape.points.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3/view.scale, 0, Math.PI*2);
    ctx.fill();
  });
}

function drawLine(shape){
  if(shape.points.length < 2) return;
  const p1 = shape.points[0];
  const p2 = shape.points[1];
  
  // Calcular dire√ß√£o e estender
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy);
  const unitX = dx / len;
  const unitY = dy / len;
  
  const ext = shape.lineLength;
  
  ctx.beginPath();
  ctx.moveTo(p1.x - unitX * ext, p1.y - unitY * ext);
  ctx.lineTo(p2.x + unitX * ext, p2.y + unitY * ext);
  ctx.stroke();
  
  // Pontos de defini√ß√£o
  ctx.fillStyle = shape.color;
  shape.points.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3/view.scale, 0, Math.PI*2);
    ctx.fill();
  });
  
  // Indicadores de extens√£o
  if(shape.showExtension){
    ctx.setLineDash([2/view.scale, 4/view.scale]);
    ctx.strokeStyle = shape.color + "66";
    ctx.beginPath();
    ctx.moveTo(p1.x - unitX * ext, p1.y - unitY * ext);
    ctx.lineTo(p1.x, p1.y);
    ctx.moveTo(p2.x, p2.y);
    ctx.lineTo(p2.x + unitX * ext, p2.y + unitY * ext);
    ctx.stroke();
  }
}

function drawCircle(shape){
  const center = shape.points[0];
  ctx.beginPath();
  ctx.arc(center.x, center.y, shape.radius, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  
  // Centro
  ctx.beginPath();
  ctx.arc(center.x, center.y, 3/view.scale, 0, Math.PI*2);
  ctx.fillStyle = shape.color;
  ctx.fill();
}

function drawPolygon(shape){
  if(shape.points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(shape.points[0].x, shape.points[0].y);
  for(let i=1; i<shape.points.length; i++){
    ctx.lineTo(shape.points[i].x, shape.points[i].y);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

function drawAnchor(x, y){
  ctx.save();
  ctx.beginPath();
  ctx.arc(x, y, 6/view.scale, 0, Math.PI*2);
  ctx.fillStyle = 'var(--accent)';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2/view.scale;
  ctx.stroke();
  
  // Cruz
  ctx.beginPath();
  ctx.moveTo(x - 10/view.scale, y);
  ctx.lineTo(x + 10/view.scale, y);
  ctx.moveTo(x, y - 10/view.scale);
  ctx.lineTo(x, y + 10/view.scale);
  ctx.strokeStyle = 'var(--accent)';
  ctx.lineWidth = 1/view.scale;
  ctx.stroke();
  ctx.restore();
}
</script>
</body>
</html>
