<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GeoLab Pro - Laboratório de Geometria</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --green: #58CC02;
      --green-dark: #46A302;
      --green-shadow: #3D8A00;
      --blue: #1CB0F6;
      --blue-dark: #0F8EC4;
      --blue-shadow: #0A6FA0;
      --red: #FF4B4B;
      --red-dark: #EA2B2B;
      --red-shadow: #C41E1E;
      --orange: #FF9600;
      --orange-dark: #D07B00;
      --purple: #CE82FF;
      --purple-dark: #9C3FA6;
      --yellow: #FFC800;
      --white: #FFFFFF;
      --off-white: #F7F7F7;
      --light-gray: #E5E5E5;
      --medium-gray: #AFAFAF;
      --dark-gray: #777777;
      --text: #3C3C3C;
      --sidebar-bg: #FFFFFF;
      --border-radius: 16px;
      --border-radius-lg: 24px;
      --shadow: 0 4px 0;
      --font: 'Nunito', sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font);
      background: var(--off-white);
      color: var(--text);
      height: 100vh;
      display: flex;
      overflow: hidden;
    }

    /* ===== SIDEBAR ===== */
    .sidebar-left {
      width: 300px;
      background: var(--white);
      border-right: 2px solid var(--light-gray);
      display: flex;
      flex-direction: column;
      z-index: 20;
      flex-shrink: 0;
    }

    .header-box {
      padding: 20px 20px 16px;
      border-bottom: 2px solid var(--light-gray);
      background: var(--white);
    }

    .logo-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    h1 {
      font-size: 1.3rem;
      font-weight: 900;
      color: var(--text);
      letter-spacing: -0.5px;
    }

    h1 span {
      color: var(--green);
    }

    .subtitle {
      font-size: 0.72rem;
      color: var(--medium-gray);
      margin-top: 2px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #studentBadge {
      display: none;
      background: linear-gradient(135deg, #E8F9D9, #D5F5AF);
      border: 2px solid var(--green);
      border-radius: 12px;
      padding: 8px 12px;
      font-size: 0.78rem;
      font-weight: 800;
      color: var(--green-dark);
      gap: 6px;
      align-items: center;
      margin-top: 12px;
    }

    #badgeNome { font-weight: 900; color: var(--green-shadow); }

    .scroll-area {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      scrollbar-width: thin;
      scrollbar-color: var(--light-gray) transparent;
      display: flex;
      flex-direction: column;
    }

    .scroll-area::-webkit-scrollbar { width: 4px; }
    .scroll-area::-webkit-scrollbar-thumb { background: var(--light-gray); border-radius: 2px; }

    /* ===== SECTION HEADERS ===== */
    h2 {
      font-size: 0.68rem;
      color: var(--medium-gray);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      padding-bottom: 10px;
      margin: 16px 0 10px 0;
      font-weight: 800;
      border-bottom: 2px solid var(--light-gray);
    }

    .control-group {
      background: var(--off-white);
      padding: 18px;
      border-radius: var(--border-radius);
      border: 2px solid var(--light-gray);
      margin-bottom: 16px;
    }

    .control-group:hover {
      border-color: var(--green);
    }

    .control-group > * + * {
      margin-top: 4px;
    }

    /* ===== BUTTONS ===== */
    button {
      width: 100%;
      padding: 13px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-family: var(--font);
      font-weight: 800;
      margin-bottom: 0;
      font-size: 0.82rem;
      transition: all 0.1s;
      position: relative;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:active {
      transform: translateY(2px);
    }

    /* Chips must never move on click */
    .popup-chip:active {
      transform: none !important;
    }

    /* Default ghost button */
    button:not([class*="btn-"]) {
      background: var(--white);
      color: var(--dark-gray);
      border: 2px solid var(--light-gray);
      box-shadow: 0 4px 0 var(--light-gray);
    }

    button:not([class*="btn-"]):hover {
      background: #E8F9D9;
      border-color: var(--green);
      color: var(--green-dark);
      box-shadow: 0 4px 0 var(--green-shadow);
    }

    button:not([class*="btn-"]):active {
      box-shadow: 0 0px 0 var(--light-gray);
      transform: translateY(4px);
    }

    .btn-primary {
      background: var(--green);
      color: white;
      box-shadow: 0 4px 0 var(--green-shadow);
      border: none;
    }
    .btn-primary:hover { background: var(--green-dark); }
    .btn-primary:active { box-shadow: 0 0px 0 var(--green-shadow); transform: translateY(4px); }

    .btn-danger {
      background: var(--red);
      color: white;
      box-shadow: 0 4px 0 var(--red-shadow);
      border: none;
    }
    .btn-danger:hover { background: var(--red-dark); }
    .btn-danger:active { box-shadow: 0 0px 0 var(--red-shadow); transform: translateY(4px); }

    .btn-success {
      background: var(--green);
      color: white;
      box-shadow: 0 4px 0 var(--green-shadow);
      border: none;
      font-size: 0.9rem;
    }
    .btn-success:hover { background: var(--green-dark); }
    .btn-success:active { box-shadow: 0 0px 0 var(--green-shadow); transform: translateY(4px); }

    .btn-anim {
      background: var(--blue);
      color: white;
      box-shadow: 0 4px 0 var(--blue-shadow);
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .btn-anim:hover { background: var(--blue-dark); }
    .btn-anim:active { box-shadow: 0 0px 0 var(--blue-shadow); transform: translateY(4px); }
    .btn-anim.active {
      background: var(--blue-dark);
      box-shadow: 0 0px 0 var(--blue-shadow);
      transform: translateY(4px);
    }

    .btn-toggle {
      background: var(--white);
      color: var(--dark-gray);
      border: 2px solid var(--light-gray);
      box-shadow: 0 4px 0 var(--light-gray);
    }
    .btn-toggle:hover {
      background: #E8F9D9;
      border-color: var(--green);
      color: var(--green-dark);
      box-shadow: 0 4px 0 var(--green-shadow);
    }
    .btn-toggle:active { box-shadow: 0 0px 0 var(--light-gray); transform: translateY(4px); }
    .btn-toggle.active {
      background: var(--purple);
      color: white;
      border-color: var(--purple-dark);
      box-shadow: 0 4px 0 var(--purple-dark);
    }

    /* Range inputs */
    input[type=range] {
      width: 100%;
      margin: 12px 0 16px;
      -webkit-appearance: none;
      background: transparent;
    }

    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 6px;
      background: var(--light-gray);
      border-radius: 3px;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--green);
      cursor: pointer;
      box-shadow: 0 3px 0 var(--green-shadow);
      border: 3px solid white;
      margin-top: -8px;
    }

    label {
      display: flex;
      justify-content: space-between;
      font-size: 0.78rem;
      color: var(--dark-gray);
      font-weight: 800;
      margin-bottom: 2px;
    }

    .value-display {
      color: var(--green);
      font-weight: 900;
      font-family: var(--font);
      background: #E8F9D9;
      padding: 2px 8px;
      border-radius: 6px;
      font-size: 0.75rem;
    }

    /* Speed control */
    .speed-control {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 16px;
      background: var(--white);
      padding: 8px 10px;
      border-radius: 10px;
      border: 2px solid var(--light-gray);
    }

    .speed-btn {
      width: 30px;
      height: 30px;
      padding: 0;
      margin: 0;
      background: var(--green);
      color: white;
      border-radius: 8px;
      font-weight: 900;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 3px 0 var(--green-shadow);
      border: none;
    }
    .speed-btn:hover { background: var(--green-dark); }
    .speed-btn:active { box-shadow: 0 0 0 var(--green-shadow); transform: translateY(3px); }

    .speed-txt {
      font-size: 0.75rem;
      font-weight: 800;
      color: var(--dark-gray);
    }

    /* ===== LAYERS PANEL ===== */
    .floating-layers {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 200px;
      background: var(--white);
      border: 2px solid var(--light-gray);
      border-radius: var(--border-radius-lg);
      padding: 14px;
      z-index: 30;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 8px 24px rgba(0,0,0,0.1);
    }

    .layers-title {
      font-size: 0.68rem;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--medium-gray);
      margin-bottom: 10px;
    }

    .layer-item {
      padding: 10px 12px;
      margin-bottom: 6px;
      background: var(--off-white);
      border: 2px solid var(--light-gray);
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.15s;
      font-size: 0.82rem;
      font-weight: 700;
      color: var(--dark-gray);
    }

    .layer-item:hover {
      border-color: var(--green);
      color: var(--green-dark);
    }

    .layer-item.active {
      background: #E8F9D9;
      border-color: var(--green);
      color: var(--green-dark);
      box-shadow: 0 3px 0 var(--green-shadow);
    }

    .layer-status {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--light-gray);
      border: 2px solid var(--medium-gray);
    }

    .layer-item.active .layer-status {
      background: var(--green);
      border-color: var(--green-shadow);
    }

    /* ===== MAIN CANVAS ===== */
    .main-content {
      flex: 1;
      position: relative;
      background: var(--white);
      background-image:
        linear-gradient(var(--light-gray) 1px, transparent 1px),
        linear-gradient(90deg, var(--light-gray) 1px, transparent 1px);
      background-size: 40px 40px;
      overflow: hidden;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    /* ===== INSTRUCTION PILL ===== */
    .instruction {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--blue);
      color: white;
      padding: 10px 22px;
      border-radius: 50px;
      box-shadow: 0 4px 0 var(--blue-shadow);
      font-weight: 800;
      font-size: 0.85rem;
      pointer-events: none;
      z-index: 10;
      white-space: nowrap;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(-4px); }
    }

    /* ===== BOTTOM TOOLBAR ===== */
    .bottom-toolbar {
      position: absolute;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      z-index: 25;
      user-select: none;
    }

    .geo-main-btn {
      width: auto;
      padding: 14px 24px;
      border-radius: 50px;
      background: var(--green);
      color: white;
      border: none;
      box-shadow: 0 5px 0 var(--green-shadow);
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 900;
      font-size: 0.95rem;
      font-family: var(--font);
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.1s;
      margin-bottom: 0;
    }

    .geo-main-btn:hover { background: var(--green-dark); }
    .geo-main-btn:active {
      box-shadow: 0 0 0 var(--green-shadow);
      transform: translateY(5px);
    }

    .geo-main-btn .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: white;
      opacity: 0.7;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.3); opacity: 1; }
    }

    .geo-main-btn .chev {
      margin-left: 4px;
      transition: transform 0.3s;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .bottom-toolbar.open .geo-main-btn .chev { transform: rotate(180deg); }

    .geo-menu {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 70px;
      width: 260px;
      background: var(--white);
      border: 2px solid var(--light-gray);
      border-radius: var(--border-radius-lg);
      box-shadow: 0 8px 0 var(--light-gray), 0 16px 40px rgba(0,0,0,0.15);
      padding: 12px;
      display: none;
      flex-direction: column;
      gap: 6px;
      max-height: 60vh;
      overflow-y: auto;
      animation: slideUp 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateX(-50%) translateY(15px) scale(0.95); }
      to { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
    }

    .bottom-toolbar.open .geo-menu { display: flex; }

    .geo-item {
      width: 100%;
      background: var(--off-white);
      border: 2px solid var(--light-gray);
      color: var(--text);
      border-radius: 12px;
      padding: 13px 16px;
      display: flex;
      align-items: center;
      margin: 0;
      font-weight: 800;
      font-family: var(--font);
      font-size: 0.88rem;
      cursor: pointer;
      transition: all 0.1s;
      box-shadow: 0 3px 0 var(--light-gray);
      text-transform: none;
      letter-spacing: 0;
    }

    .geo-item:hover {
      background: #E8F9D9;
      border-color: var(--green);
      color: var(--green-dark);
      box-shadow: 0 3px 0 var(--green-shadow);
    }

    .geo-item:active {
      box-shadow: 0 0 0 var(--light-gray);
      transform: translateY(3px);
    }

    .geo-item .left {
      display: flex;
      align-items: center;
    }

    /* ===== QUICK TOOLS GRID ===== */
    .quick-tools {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }

    .quick-tools button {
      margin-bottom: 0;
    }

    /* ===== EMPTY STATE ===== */
    #emptyStateMsg {
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
      padding: 32px 20px;
    }

    .empty-icon {
      font-size: 3.5rem;
      margin-bottom: 12px;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    #emptyStateMsg p {
      font-weight: 800;
      color: var(--medium-gray);
      font-size: 0.85rem;
    }

    #emptyStateMsg p:last-child {
      font-size: 0.75rem;
      margin-top: 6px;
      font-weight: 600;
    }

    /* ===== TOOLTIP ===== */
    .tooltip {
      position: absolute;
      background: var(--text);
      color: white;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 0.75rem;
      font-weight: 700;
      font-family: var(--font);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
    }

    /* ===== FOOTER ===== */
    .footer {
      font-size: 0.68rem;
      color: var(--medium-gray);
      text-align: center;
      padding: 12px;
      border-top: 2px solid var(--light-gray);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* ===== POPUP OVERLAY ===== */
    #popupOverlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(8px);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeInOverlay 0.4s ease;
    }

    @keyframes fadeInOverlay {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #popupBox {
      width: 460px;
      max-width: 95vw;
      background: var(--white);
      border: 3px solid var(--light-gray);
      border-radius: 28px;
      box-shadow: 0 8px 0 var(--light-gray), 0 24px 60px rgba(0,0,0,0.12);
      padding: 40px 36px 32px;
      position: relative;
      animation: popupIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes popupIn {
      from { opacity: 0; transform: scale(0.85) translateY(30px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }

    .popup-header {
      text-align: center;
      margin-bottom: 28px;
    }

    .popup-mascot {
      font-size: 4rem;
      display: block;
      margin-bottom: 8px;
      animation: bounce 2s infinite;
    }

    .popup-title {
      font-size: 2rem;
      font-weight: 900;
      color: var(--text);
      letter-spacing: -1px;
    }

    .popup-title span { color: var(--green); }

    .popup-tagline {
      font-size: 0.85rem;
      color: var(--medium-gray);
      font-weight: 700;
      margin-top: 4px;
    }

    .popup-divider {
      height: 2px;
      background: var(--light-gray);
      border-radius: 1px;
      margin: 0 0 24px;
    }

    .popup-field {
      margin-bottom: 18px;
    }

    .popup-field label {
      display: block;
      font-size: 0.72rem;
      font-weight: 900;
      color: var(--medium-gray);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .popup-input {
      width: 100%;
      padding: 14px 16px;
      background: var(--off-white);
      border: 2px solid var(--light-gray);
      border-radius: 14px;
      color: var(--text);
      font-size: 0.95rem;
      font-family: var(--font);
      font-weight: 700;
      outline: none;
      transition: all 0.2s;
    }

    .popup-input::placeholder {
      color: var(--medium-gray);
      font-weight: 600;
    }

    .popup-input:focus {
      border-color: var(--blue);
      background: var(--white);
      box-shadow: 0 0 0 3px rgba(28, 176, 246, 0.2);
    }

    .popup-select-group {
      display: flex;
      gap: 8px;
      flex-wrap: nowrap;
    }

    .popup-chip {
      flex: 1;
      padding: 12px 8px;
      border-radius: 12px;
      background: var(--off-white);
      border: 2px solid var(--light-gray);
      color: var(--dark-gray);
      font-size: 0.82rem;
      font-weight: 800;
      font-family: var(--font);
      cursor: pointer;
      transition: border-color 0.1s, background 0.1s, color 0.1s, box-shadow 0.1s;
      text-align: center;
      box-shadow: 0 3px 0 var(--light-gray);
      margin-bottom: 0;
      text-transform: none;
      letter-spacing: 0;
      transform: none !important;
      user-select: none;
    }

    .popup-chip:hover {
      border-color: var(--green);
      color: var(--green-dark);
      box-shadow: 0 3px 0 var(--green-shadow);
    }

    .popup-chip:active {
      background: #E8F9D9;
      border-color: var(--green);
    }

    .popup-chip.selected {
      background: var(--green);
      border-color: var(--green-dark);
      color: white;
      box-shadow: 0 4px 0 var(--green-shadow);
    }

    .popup-chip.selected::after {
      content: ' ✓';
      font-size: 0.9em;
    }

    .popup-error {
      margin-top: 12px;
      padding: 10px 16px;
      background: #FFE5E5;
      border: 2px solid var(--red);
      border-radius: 10px;
      color: var(--red-dark);
      font-size: 0.82rem;
      font-weight: 800;
      display: none;
      text-align: center;
    }

    .popup-actions {
      display: flex;
      gap: 10px;
      margin-top: 24px;
    }

    .btn-popup-enter {
      flex: 1;
      width: 100%;
      padding: 16px;
      border-radius: 14px;
      background: var(--green);
      border: none;
      color: white;
      font-size: 1rem;
      font-weight: 900;
      font-family: var(--font);
      cursor: pointer;
      transition: all 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 5px 0 var(--green-shadow);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0;
    }

    .btn-popup-enter:hover { background: var(--green-dark); }
    .btn-popup-enter:active {
      box-shadow: 0 0 0 var(--green-shadow);
      transform: translateY(5px);
    }

    .btn-popup-teacher {
      flex: 1;
      width: 100%;
      padding: 16px;
      border-radius: 14px;
      background: var(--white);
      border: 2px solid var(--light-gray);
      color: var(--medium-gray);
      font-size: 0.82rem;
      font-weight: 800;
      font-family: var(--font);
      cursor: pointer;
      transition: all 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 0 var(--light-gray);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0;
    }

    .btn-popup-teacher:hover {
      border-color: var(--orange);
      color: var(--orange-dark);
      box-shadow: 0 4px 0 var(--orange-dark);
    }

    .btn-popup-teacher:active {
      box-shadow: 0 0 0 var(--light-gray);
      transform: translateY(4px);
    }

    /* ===== PROFESSOR MODAL ===== */
    #professorModal {
      position: fixed;
      inset: 0;
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.85);
      backdrop-filter: blur(8px);
    }

    #professorModal.visible {
      display: flex;
      animation: fadeInOverlay 0.3s ease;
    }

    .prof-box {
      width: 360px;
      max-width: 92vw;
      background: var(--white);
      border: 3px solid var(--orange);
      border-radius: 24px;
      padding: 36px 32px;
      box-shadow: 0 8px 0 var(--orange-dark), 0 24px 60px rgba(0,0,0,0.1);
      animation: popupIn 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
      position: relative;
    }

    .prof-box h3 {
      font-size: 1.3rem;
      font-weight: 900;
      color: var(--orange-dark);
      margin-bottom: 4px;
      text-align: center;
    }

    .prof-box p {
      text-align: center;
      font-size: 0.82rem;
      color: var(--medium-gray);
      margin-bottom: 20px;
      font-weight: 700;
    }

    .prof-close {
      position: absolute;
      top: 14px;
      right: 14px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--off-white);
      border: 2px solid var(--light-gray);
      color: var(--medium-gray);
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      margin: 0;
      box-shadow: 0 3px 0 var(--light-gray);
      transition: all 0.1s;
    }

    .prof-close:hover {
      background: #FFE5E5;
      border-color: var(--red);
      color: var(--red);
      box-shadow: 0 3px 0 var(--red-shadow);
    }

    .prof-close:active {
      box-shadow: 0 0 0 var(--light-gray);
      transform: translateY(3px);
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .sidebar-left {
        position: absolute;
        transform: translateX(-100%);
        height: 100%;
        z-index: 50;
      }
      .sidebar-left.open { transform: translateX(0); }
      .floating-layers { width: 170px; right: 10px; top: 10px; }
    }
  </style>
</head>

<body>

  <!-- ===== POPUP DE IDENTIFICAÇÃO ===== -->
  <div id="popupOverlay">
    <div id="popupBox">
      <div class="popup-header">
        <div class="popup-title">Geo<span>Lab</span> Pro</div>
        <div class="popup-tagline">Laboratório de Geometria Interativo</div>
      </div>
      <div class="popup-divider"></div>

      <div class="popup-field">
        <label>Qual é o seu nome?</label>
        <input type="text" id="inputNome" class="popup-input" placeholder="Digite seu nome completo..." autocomplete="off" />
      </div>

      <div class="popup-field">
        <label>Qual é o seu ano?</label>
        <div class="popup-select-group" id="grupoAno">
          <button type="button" class="popup-chip" data-tipo="ano" data-valor="6°">6º Ano</button>
          <button type="button" class="popup-chip" data-tipo="ano" data-valor="7°">7º Ano</button>
          <button type="button" class="popup-chip" data-tipo="ano" data-valor="8°">8º Ano</button>
          <button type="button" class="popup-chip" data-tipo="ano" data-valor="9°">9º Ano</button>
        </div>
      </div>

      <div class="popup-field">
        <label>Qual é a sua turma?</label>
        <div class="popup-select-group" id="grupoTurma">
          <button type="button" class="popup-chip" data-tipo="turma" data-valor="A">A</button>
          <button type="button" class="popup-chip" data-tipo="turma" data-valor="B">B</button>
          <button type="button" class="popup-chip" data-tipo="turma" data-valor="C">C</button>
        </div>
      </div>

      <div class="popup-error" id="popupError">Preencha todos os campos para continuar.</div>

      <div class="popup-actions">
        <button type="button" class="btn-popup-enter" id="btnEntrar">COMEÇAR</button>
      </div>
      <div class="popup-actions" style="margin-top:8px">
        <button type="button" class="btn-popup-teacher" id="btnProfessor">ÁREA DO PROFESSOR</button>
      </div>
    </div>
  </div>

  <!-- Modal Área do Professor -->
  <div id="professorModal">
    <div class="prof-box">
      <button class="prof-close" onclick="fecharAreaProfessor()">✕</button>
      <h3>Área do Professor</h3>
      <p>Digite a senha para acessar o painel docente</p>
      <div class="popup-field">
        <label>Senha</label>
        <input type="password" id="inputSenhaProfessor" class="popup-input" placeholder="••••••••" />
      </div>
      <div class="popup-error" id="professorError">Senha incorreta. Tente novamente.</div>
      <button class="btn-popup-enter" onclick="verificarSenhaProfessor()" style="margin-top:16px">
        Acessar Painel
      </button>
    </div>
  </div>

  <!-- ===== SIDEBAR ===== -->
  <aside class="sidebar-left">
    <div class="header-box">
      <div class="logo-row">
        <div>
          <h1>Geo<span>Lab</span> Pro</h1>
          <div class="subtitle">Laboratório de Geometria</div>
        </div>
      </div>
      <div id="studentBadge">
        <span id="badgeNome"></span> &bull; <span id="badgeInfo"></span>
      </div>
    </div>

    <div class="scroll-area" id="controlsPanel">

      <!-- Empty state shown when no figure is selected -->
      <div id="emptyStateMsg" style="display:flex; flex-direction:column; align-items:center; justify-content:center; flex:1; padding:40px 20px; text-align:center; min-height:300px;">
        <div style="font-size:3rem; opacity:0.1; margin-bottom:20px; line-height:1; font-weight:900;">◻</div>
        <p style="font-weight:800; color:var(--medium-gray); font-size:0.9rem;">Nenhuma figura selecionada</p>
        <p style="font-size:0.78rem; margin-top:8px; font-weight:600; color:#C8C8C8;">Crie uma figura para ver as opções</p>
      </div>

      <!-- Controls shown when a figure is selected and closed -->
      <div id="figureControls" style="display:none;">

        <div class="control-group" style="border: 2px solid var(--orange); background: #FFF8E5;">
          <h2 style="color: var(--orange-dark);">Centro da Figura</h2>
          <p style="font-size:0.75rem; color:var(--dark-gray); margin-bottom:14px; font-weight:700;">
            Arraste o ponto laranja para mover o eixo de rotação.
          </p>
          <button class="btn-toggle" onclick="resetAnchor()">
            Resetar Centro
          </button>
        </div>

        <div class="control-group">
          <h2>Translação</h2>
          <label>Eixo X <span id="valTx" class="value-display">0</span></label>
          <input type="range" id="inputTx" min="-500" max="500" value="0" oninput="updateShapeData()">
          <button class="btn-anim" id="animXBtn" onclick="toggleAnim('x')">
            Animar X
          </button>

          <label style="margin-top:20px;">Eixo Y <span id="valTy" class="value-display">0</span></label>
          <input type="range" id="inputTy" min="-500" max="500" value="0" oninput="updateShapeData()">
          <button class="btn-anim" id="animYBtn" onclick="toggleAnim('y')">
            Animar Y
          </button>

          <div class="speed-control">
            <button class="speed-btn" onclick="changeSpeed('trans', -1)">−</button>
            <span class="speed-txt">Velocidade: <span id="speedTransDisplay" class="value-display">1x</span></span>
            <button class="speed-btn" onclick="changeSpeed('trans', 1)">+</button>
          </div>
        </div>

        <div class="control-group">
          <h2>Rotação</h2>
          <label>Ângulo <span id="valRot" class="value-display">0°</span></label>
          <input type="range" id="inputRot" min="0" max="360" value="0" oninput="updateShapeData()">
          <button class="btn-anim" id="animRotBtn" onclick="toggleAnim('rot')">
            Animar Rotação
          </button>

          <div class="speed-control">
            <button class="speed-btn" onclick="changeSpeed('rot', -1)">−</button>
            <span class="speed-txt">Velocidade: <span id="speedRotDisplay" class="value-display">1x</span></span>
            <button class="speed-btn" onclick="changeSpeed('rot', 1)">+</button>
          </div>
        </div>

        <div class="control-group">
          <h2>Escala</h2>
          <label>Tamanho <span id="valScale" class="value-display">100%</span></label>
          <input type="range" id="inputScale" min="10" max="300" value="100" oninput="updateShapeData()">
          <button class="btn-toggle" onclick="resetScale()">Resetar Tamanho</button>
        </div>

        <div class="control-group">
          <h2>Simetria (Espelho)</h2>
          <div class="quick-tools">
            <button id="btnRefX" class="btn-toggle" onclick="toggleReflect('x')">Espelho X</button>
            <button id="btnRefY" class="btn-toggle" onclick="toggleReflect('y')">Espelho Y</button>
          </div>
        </div>

        <button class="btn-danger" onclick="deleteCurrentLayer()" style="margin-top:8px;">
          Excluir Figura
        </button>

      </div><!-- end figureControls -->
    </div>

    <div class="footer">
      Desenvolvido por Gilberto Fernandes
    </div>
  </aside>

  <!-- ===== CANVAS PRINCIPAL ===== -->
  <main class="main-content" id="mainArea">
    <div class="instruction" id="instructionText">
      Clique em "Figuras Geométricas" para começar
    </div>
    <canvas id="canvas"></canvas>
    <div class="tooltip" id="tooltip"></div>

    <!-- Barra inferior de ferramentas -->
    <div class="bottom-toolbar" id="bottomToolbar">
      <button class="geo-main-btn" id="geoMainBtn" type="button">
        <span>Figuras Geométricas</span>
        <span class="chev">▼</span>
      </button>

      <div class="geo-menu" id="geoMenu">
        <button class="geo-item" onclick="addPresetShape('circle')">
          <span class="left">Círculo</span>
        </button>
        <button class="geo-item" onclick="addPresetShape('triangle')">
          <span class="left">Triângulo</span>
        </button>
        <button class="geo-item" onclick="addPresetShape('square')">
          <span class="left">Quadrado</span>
        </button>
        <button class="geo-item" onclick="addPresetShape('rect')">
          <span class="left">Retângulo</span>
        </button>
        <button class="geo-item" onclick="addPresetShape('pent')">
          <span class="left">Pentágono</span>
        </button>
        <button class="geo-item" onclick="addPresetShape('hex')">
          <span class="left">Hexágono</span>
        </button>
      </div>
    </div>
  </main>

  <!-- ===== FLOATING LAYERS ===== -->
  <div class="floating-layers">
    <div class="layers-title">Figuras</div>
    <button class="btn-success" onclick="createNewLayer()" style="margin-bottom:10px; width:100%; padding:12px; font-size:0.82rem;">
      + Nova Figura
    </button>
    <div id="layersList"></div>
  </div>

<script>
/* =========================================================
   PROTEÇÃO BÁSICA
========================================================= */
(function hardenPage(){
  document.addEventListener('contextmenu', (e)=>e.preventDefault(), {capture:true});
  document.addEventListener('dragstart', (e)=>e.preventDefault(), {capture:true});
  document.addEventListener('selectstart', (e)=>{
    const tag = e.target?.tagName?.toLowerCase?.() || '';
    if(tag === 'input' || tag === 'textarea') return;
    e.preventDefault();
  }, {capture:true});
})();

/* =========================================================
   APP GEOLAB PRO
========================================================= */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const mainArea = document.getElementById('mainArea');
const tooltip = document.getElementById('tooltip');

let shapes = [];
let activeIndex = -1;
let mode = 'IDLE'; // IDLE, DRAWING, DRAGGING_ANCHOR, DRAGGING_SHAPE
let currentTool = 'polygon'; // polygon, point, segment, line
let mouseScreen = { x: 0, y: 0 };
let mouseWorld = { x: 0, y: 0 };
let dragStartWorld = { x: 0, y: 0 };

// View (Zoom e Pan)
let view = {
  scale: 1.0,
  offsetX: 0,
  offsetY: 0,
  minScale: 0.2,
  maxScale: 5.0
};

const colors = ['#58CC02', '#1CB0F6', '#FF9600', '#FF4B4B', '#CE82FF', '#FF6B9D', '#00CD9C'];

// Tipos de forma
const SHAPE_TYPES = {
  POINT: 'point',
  SEGMENT: 'segment',
  LINE: 'line',
  POLYGON: 'polygon',
  CIRCLE: 'circle'
};

function resizeCanvas(){
  canvas.width = mainArea.clientWidth;
  canvas.height = mainArea.clientHeight;
  if (view.offsetX === 0 && view.offsetY === 0) {
    view.offsetX = canvas.width / 2;
    view.offsetY = canvas.height / 2;
  }
  draw();
}
window.addEventListener('resize', resizeCanvas);
setTimeout(resizeCanvas, 100);

/* ===================== MENU INFERIOR ===================== */
const bottomToolbar = document.getElementById('bottomToolbar');
const geoMainBtn = document.getElementById('geoMainBtn');

function toggleGeoMenu(){
  bottomToolbar.classList.toggle('open');
}
geoMainBtn.addEventListener('click', (e)=>{
  e.stopPropagation();
  toggleGeoMenu();
});
document.addEventListener('click', ()=>{
  bottomToolbar.classList.remove('open');
});
document.getElementById('geoMenu').addEventListener('click', (e)=>e.stopPropagation());

/* ===================== COORDENADAS ===================== */
function screenToWorld(x, y){
  return {
    x: (x - view.offsetX) / view.scale,
    y: (y - view.offsetY) / view.scale
  };
}
function worldToScreen(x, y){
  return {
    x: x * view.scale + view.offsetX,
    y: y * view.scale + view.offsetY
  };
}

/* ===================== ZOOM COM SCROLL ===================== */
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const before = screenToWorld(sx, sy);
  
  const zoomIn = e.deltaY < 0;
  const factor = zoomIn ? 1.15 : 0.85;
  const newScale = Math.max(view.minScale, Math.min(view.maxScale, view.scale * factor));
  view.scale = newScale;
  
  view.offsetX = sx - before.x * view.scale;
  view.offsetY = sy - before.y * view.scale;
  
  mouseScreen = {x: sx, y: sy};
  mouseWorld = screenToWorld(sx, sy);
  draw();
}, { passive: false });

/* ===================== GERENCIAMENTO DE CAMADAS ===================== */
function createNewLayer(){
  const newShape = {
    id: Date.now(),
    name: `Figura ${shapes.length + 1}`,
    type: SHAPE_TYPES.POLYGON,
    points: [],
    color: colors[shapes.length % colors.length],
    isClosed: false,
    tx: 0, ty: 0, rotation: 0,
    scale: 1.0,
    reflectX: false, reflectY: false,
    anchor: { x: 0, y: 0 },
    anim: { x: false, y: false, rot: false, dirX: 1, dirY: 1 },
    speed: { trans: 1.0, rot: 1.0 },
    pointRadius: 5,
    lineLength: 1000,
    showExtension: true
  };

  shapes.push(newShape);
  selectLayer(shapes.length - 1);
  currentTool = 'polygon';
  mode = 'DRAWING';
  updateUI();
  showInstruction(`Criando ${newShape.name}: Clique para adicionar vértices. Clique no primeiro ponto para fechar.`);
}

function selectLayer(index){
  if(index < 0 || index >= shapes.length){
    activeIndex = -1;
    mode = 'IDLE';
  } else {
    if(activeIndex !== -1 && !shapes[activeIndex].isClosed && shapes[activeIndex].type !== SHAPE_TYPES.POINT){
      alert("Feche a forma atual antes de trocar.");
      return;
    }
    activeIndex = index;
    const shape = shapes[index];
    mode = shape.isClosed ? 'IDLE' : 'DRAWING';
    currentTool = shape.type === SHAPE_TYPES.POLYGON && !shape.isClosed ? 'polygon' : shape.type;
  }
  updateUI();
  draw();
}

function deleteCurrentLayer(){
  if(activeIndex === -1) return;
  shapes.splice(activeIndex, 1);
  activeIndex = -1;
  mode = 'IDLE';
  updateUI();
  draw();
}

function updateUI(){
  const layersList = document.getElementById('layersList');
  layersList.innerHTML = '';

  shapes.forEach((shape, idx)=>{
    const div = document.createElement('div');
    div.className = `layer-item ${idx === activeIndex ? 'active' : ''}`;
    div.onclick = ()=>selectLayer(idx);
    
    const icon = getShapeIcon(shape.type);
    div.innerHTML = `
      <span style="display:flex; align-items:center; gap:8px;">
        <span style="font-size:1.1rem;">${icon}</span>
        ${shape.name}
      </span>
      <div class="layer-status"></div>
    `;
    layersList.appendChild(div);
  });

  const controls = document.getElementById('figureControls');
  const emptyMsg = document.getElementById('emptyStateMsg');

  if(activeIndex !== -1 && shapes[activeIndex].isClosed){
    controls.style.display = 'block';
    emptyMsg.style.display = 'none';

    const s = shapes[activeIndex];
    document.getElementById('inputTx').value = s.tx;
    document.getElementById('inputTy').value = s.ty;
    document.getElementById('inputRot').value = s.rotation;
    document.getElementById('inputScale').value = Math.round(s.scale * 100);

    document.getElementById('btnRefX').classList.toggle('active', s.reflectX);
    document.getElementById('btnRefY').classList.toggle('active', s.reflectY);

    document.getElementById('animXBtn').classList.toggle('active', s.anim.x);
    document.getElementById('animYBtn').classList.toggle('active', s.anim.y);
    document.getElementById('animRotBtn').classList.toggle('active', s.anim.rot);

    hideInstruction();
  } else {
    controls.style.display = 'none';
    emptyMsg.style.display = 'flex';
  }
  updateLabelValues();
}

function getShapeIcon(type){
  const icons = {
    [SHAPE_TYPES.POINT]: '•',
    [SHAPE_TYPES.SEGMENT]: '━',
    [SHAPE_TYPES.LINE]: '↔',
    [SHAPE_TYPES.POLYGON]: '⬡',
    [SHAPE_TYPES.CIRCLE]: '◯'
  };
  return icons[type] || '⬡';
}

function updateLabelValues(){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  const txEl = document.getElementById('valTx');
  const tyEl = document.getElementById('valTy');
  const rotEl = document.getElementById('valRot');
  const scaleEl = document.getElementById('valScale');
  const speedTransEl = document.getElementById('speedTransDisplay');
  const speedRotEl = document.getElementById('speedRotDisplay');
  
  if(txEl) txEl.textContent = Math.round(s.tx);
  if(tyEl) tyEl.textContent = Math.round(s.ty);
  if(rotEl) rotEl.textContent = Math.round(s.rotation) + '°';
  if(scaleEl) scaleEl.textContent = Math.round(s.scale * 100) + '%';
  if(speedTransEl) speedTransEl.textContent = s.speed.trans + 'x';
  if(speedRotEl) speedRotEl.textContent = s.speed.rot + 'x';
}

/* ===================== CONTROLES DE FORMA ===================== */
function updateShapeData(){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  s.tx = parseFloat(document.getElementById('inputTx').value);
  s.ty = parseFloat(document.getElementById('inputTy').value);
  s.rotation = parseFloat(document.getElementById('inputRot').value);
  s.scale = parseFloat(document.getElementById('inputScale').value) / 100;
  updateLabelValues();
  draw();
}

function resetScale(){
  if(activeIndex === -1) return;
  shapes[activeIndex].scale = 1.0;
  document.getElementById('inputScale').value = 100;
  updateLabelValues();
  draw();
}

function resetAnchor(){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  const pts = s.points;
  if(pts.length === 0) return;
  const cx = pts.reduce((a,p)=>a+p.x,0)/pts.length;
  const cy = pts.reduce((a,p)=>a+p.y,0)/pts.length;
  s.anchor = { x: cx, y: cy };
  draw();
}

function toggleReflect(axis){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  if(axis === 'x') s.reflectX = !s.reflectX;
  if(axis === 'y') s.reflectY = !s.reflectY;
  document.getElementById('btnRefX').classList.toggle('active', s.reflectX);
  document.getElementById('btnRefY').classList.toggle('active', s.reflectY);
  draw();
}

/* ===================== ANIMAÇÕES ===================== */
let animFrame = null;
let lastTime = 0;

function toggleAnim(type){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  s.anim[type] = !s.anim[type];
  
  const hasAny = shapes.some(sh => sh.anim.x || sh.anim.y || sh.anim.rot);
  if(hasAny && !animFrame){
    lastTime = performance.now();
    animFrame = requestAnimationFrame(animLoop);
  } else if(!hasAny && animFrame){
    cancelAnimationFrame(animFrame);
    animFrame = null;
  }
  updateUI();
}

function animLoop(now){
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  
  shapes.forEach(s => {
    const spd = s.speed.trans * 50;
    const rotSpd = s.speed.rot * 60;
    
    if(s.anim.x){
      s.tx += spd * s.anim.dirX * dt;
      if(s.tx > 300){ s.anim.dirX = -1; }
      else if(s.tx < -300){ s.anim.dirX = 1; }
      const el = document.getElementById('inputTx');
      if(el && activeIndex !== -1 && shapes[activeIndex] === s) el.value = s.tx;
    }
    if(s.anim.y){
      s.ty += spd * s.anim.dirY * dt;
      if(s.ty > 300){ s.anim.dirY = -1; }
      else if(s.ty < -300){ s.anim.dirY = 1; }
      const el = document.getElementById('inputTy');
      if(el && activeIndex !== -1 && shapes[activeIndex] === s) el.value = s.ty;
    }
    if(s.anim.rot){
      s.rotation = (s.rotation + rotSpd * dt) % 360;
      const el = document.getElementById('inputRot');
      if(el && activeIndex !== -1 && shapes[activeIndex] === s) el.value = s.rotation;
    }
  });
  
  updateLabelValues();
  draw();
  animFrame = requestAnimationFrame(animLoop);
}

function changeSpeed(type, delta){
  if(activeIndex === -1) return;
  const s = shapes[activeIndex];
  const speeds = [0.25, 0.5, 1, 2, 3, 5];
  let idx = speeds.indexOf(s.speed[type]);
  idx = Math.max(0, Math.min(speeds.length - 1, idx + delta));
  s.speed[type] = speeds[idx];
  updateLabelValues();
}

/* ===================== PRESET SHAPES ===================== */
function addPresetShape(type){
  const cx = 0, cy = 0;
  createNewLayer();
  const s = shapes[shapes.length - 1];
  
  switch(type){
    case 'circle':
      s.type = SHAPE_TYPES.CIRCLE;
      s.points = [{ x: cx, y: cy }];
      s.radius = 80;
      s.isClosed = true;
      break;
    case 'triangle': {
      const r = 80;
      s.points = [
        { x: cx, y: cy - r },
        { x: cx + r * Math.cos(Math.PI/6), y: cy + r * Math.sin(Math.PI/6) },
        { x: cx - r * Math.cos(Math.PI/6), y: cy + r * Math.sin(Math.PI/6) }
      ];
      s.isClosed = true;
      break;
    }
    case 'square': {
      const h = 70;
      s.points = [
        { x: cx - h, y: cy - h },
        { x: cx + h, y: cy - h },
        { x: cx + h, y: cy + h },
        { x: cx - h, y: cy + h }
      ];
      s.isClosed = true;
      break;
    }
    case 'rect': {
      s.points = [
        { x: cx - 100, y: cy - 60 },
        { x: cx + 100, y: cy - 60 },
        { x: cx + 100, y: cy + 60 },
        { x: cx - 100, y: cy + 60 }
      ];
      s.isClosed = true;
      break;
    }
    case 'pent': {
      const rp = 80;
      for(let i = 0; i < 5; i++){
        const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
        s.points.push({ x: cx + rp * Math.cos(angle), y: cy + rp * Math.sin(angle) });
      }
      s.isClosed = true;
      break;
    }
    case 'hex': {
      const rh = 80;
      for(let i = 0; i < 6; i++){
        const angle = (i * 2 * Math.PI / 6);
        s.points.push({ x: cx + rh * Math.cos(angle), y: cy + rh * Math.sin(angle) });
      }
      s.isClosed = true;
      break;
    }
  }

  s.anchor = {
    x: s.points.reduce((a,p)=>a+p.x,0) / s.points.length,
    y: s.points.reduce((a,p)=>a+p.y,0) / s.points.length
  };

  mode = 'IDLE';
  updateUI();
  draw();
  bottomToolbar.classList.remove('open');
}

/* ===================== EVENTOS DO CANVAS ===================== */
let isPanning = false;
let panStart = { x: 0, y: 0 };
let panStartOffset = { x: 0, y: 0 };
let draggingVertexIndex = -1; // index of vertex being dragged

canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  mouseScreen = { x: sx, y: sy };
  mouseWorld = screenToWorld(sx, sy);

  if(e.button === 1 || (e.button === 0 && e.altKey)){
    isPanning = true;
    panStart = { x: sx, y: sy };
    panStartOffset = { x: view.offsetX, y: view.offsetY };
    canvas.style.cursor = 'grabbing';
    return;
  }

  if(mode === 'IDLE' && activeIndex !== -1){
    const s = shapes[activeIndex];

    // Check vertex handles first (only for closed polygons)
    if(s.isClosed && (s.type === SHAPE_TYPES.POLYGON || s.type === SHAPE_TYPES.SEGMENT)){
      const VERTEX_HIT = 14; // px
      const transformed = getTransformedPoints(s);
      for(let vi = 0; vi < transformed.length; vi++){
        const sp = worldToScreen(transformed[vi].x, transformed[vi].y);
        if(Math.hypot(sx - sp.x, sy - sp.y) < VERTEX_HIT){
          draggingVertexIndex = vi;
          mode = 'DRAGGING_VERTEX';
          return;
        }
      }
    }

    const anchorScreen = worldToScreen(s.anchor.x + s.tx, s.anchor.y + s.ty);
    const distAnchor = Math.hypot(sx - anchorScreen.x, sy - anchorScreen.y);
    
    if(distAnchor < 12){
      mode = 'DRAGGING_ANCHOR';
      return;
    }

    const transformed = getTransformedPoints(s);

    // Check if click is inside the polygon (point-in-polygon test)
    let hitShape = false;
    if(s.type === SHAPE_TYPES.CIRCLE){
      const cx = s.points[0].x + s.tx;
      const cy = s.points[0].y + s.ty;
      const r = s.radius * s.scale;
      const mw = mouseWorld;
      hitShape = Math.hypot(mw.x - cx, mw.y - cy) <= r;
    } else if(transformed.length >= 3){
      // Ray casting algorithm for polygon
      const mw = mouseWorld;
      let inside = false;
      for(let i = 0, j = transformed.length - 1; i < transformed.length; j = i++){
        const xi = transformed[i].x, yi = transformed[i].y;
        const xj = transformed[j].x, yj = transformed[j].y;
        const intersect = ((yi > mw.y) !== (yj > mw.y)) &&
          (mw.x < (xj - xi) * (mw.y - yi) / (yj - yi) + xi);
        if(intersect) inside = !inside;
      }
      hitShape = inside;
      // Also allow clicking near edges (within ~10px screen)
      if(!hitShape){
        for(let i = 0, j = transformed.length - 1; i < transformed.length; j = i++){
          const ps = worldToScreen(transformed[i].x, transformed[i].y);
          if(Math.hypot(sx - ps.x, sy - ps.y) < 10){ hitShape = true; break; }
          j = i;
        }
      }
    } else {
      // Segment/line - click near the line
      transformed.forEach(p => {
        const ps = worldToScreen(p.x, p.y);
        if(Math.hypot(sx - ps.x, sy - ps.y) < 16) hitShape = true;
      });
    }

    if(hitShape){
      mode = 'DRAGGING_SHAPE';
      dragStartWorld = { ...mouseWorld };
    }
  }

  if(mode === 'DRAWING' && activeIndex !== -1){
    const s = shapes[activeIndex];
    if(s.type === SHAPE_TYPES.POLYGON && s.points.length >= 3){
      const first = worldToScreen(s.points[0].x, s.points[0].y);
      const dist = Math.hypot(sx - first.x, sy - first.y);
      if(dist < 15){
        s.isClosed = true;
        mode = 'IDLE';
        s.anchor = {
          x: s.points.reduce((a,p)=>a+p.x,0)/s.points.length,
          y: s.points.reduce((a,p)=>a+p.y,0)/s.points.length
        };
        updateUI();
        draw();
        return;
      }
    }
    
    const worldPt = screenToWorld(sx, sy);
    if(s.type === SHAPE_TYPES.POINT){
      s.points = [worldPt];
      s.isClosed = true;
      mode = 'IDLE';
      s.anchor = { ...worldPt };
      updateUI();
    } else if(s.type === SHAPE_TYPES.SEGMENT || s.type === SHAPE_TYPES.LINE){
      s.points.push(worldPt);
      if(s.points.length >= 2){
        s.isClosed = true;
        mode = 'IDLE';
        s.anchor = {
          x: (s.points[0].x + s.points[1].x) / 2,
          y: (s.points[0].y + s.points[1].y) / 2
        };
        updateUI();
      }
    } else {
      s.points.push(worldPt);
    }
    draw();
  }
});

canvas.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  mouseScreen = { x: sx, y: sy };
  mouseWorld = screenToWorld(sx, sy);

  // Update cursor based on what's hovered
  if(mode === 'IDLE' && activeIndex !== -1){
    const s = shapes[activeIndex];
    const transformed = getTransformedPoints(s);

    // Check vertex handles first
    let overVertex = false;
    if(s.isClosed && (s.type === SHAPE_TYPES.POLYGON || s.type === SHAPE_TYPES.SEGMENT)){
      for(let vi = 0; vi < transformed.length; vi++){
        const sp = worldToScreen(transformed[vi].x, transformed[vi].y);
        if(Math.hypot(sx - sp.x, sy - sp.y) < 14){ overVertex = true; break; }
      }
    }

    if(overVertex){
      canvas.style.cursor = 'grab';
    } else {
      // Check if hovering inside shape body
      let overShape = false;
      const mw = mouseWorld;
      if(s.type === SHAPE_TYPES.CIRCLE){
        const cx = s.points[0].x + s.tx;
        const cy = s.points[0].y + s.ty;
        overShape = Math.hypot(mw.x - cx, mw.y - cy) <= s.radius * s.scale;
      } else if(transformed.length >= 3){
        let inside = false;
        for(let i = 0, j = transformed.length - 1; i < transformed.length; j = i++){
          const xi = transformed[i].x, yi = transformed[i].y;
          const xj = transformed[j].x, yj = transformed[j].y;
          if(((yi > mw.y) !== (yj > mw.y)) && (mw.x < (xj - xi) * (mw.y - yi) / (yj - yi) + xi))
            inside = !inside;
        }
        overShape = inside;
      }
      canvas.style.cursor = overShape ? 'move' : 'default';
    }
  } else if(mode === 'DRAWING'){
    canvas.style.cursor = 'crosshair';
  } else if(mode === 'DRAGGING_VERTEX'){
    canvas.style.cursor = 'grabbing';
  } else if(mode === 'DRAGGING_SHAPE'){
    canvas.style.cursor = 'grabbing';
  }

  if(isPanning){
    view.offsetX = panStartOffset.x + (sx - panStart.x);
    view.offsetY = panStartOffset.y + (sy - panStart.y);
    draw();
    return;
  }

  if(mode === 'DRAGGING_VERTEX' && activeIndex !== -1 && draggingVertexIndex !== -1){
    const s = shapes[activeIndex];

    // Convert mouseWorld back to local (pre-transform) space by inverting all transforms
    const ax = s.anchor.x;
    const ay = s.anchor.y;
    const angle = -(s.rotation * Math.PI / 180);
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const scaleX = s.scale * (s.reflectX ? -1 : 1);
    const scaleY = s.scale * (s.reflectY ? -1 : 1);

    // Step 1: remove translation and anchor offset
    const wx = mouseWorld.x - s.tx - ax;
    const wy = mouseWorld.y - s.ty - ay;

    // Step 2: invert rotation
    const rx = wx * cos - wy * sin;
    const ry = wx * sin + wy * cos;

    // Step 3: invert scale + reflection
    const lx = rx / scaleX + ax;
    const ly = ry / scaleY + ay;

    s.points[draggingVertexIndex] = { x: lx, y: ly };
    // Do NOT update anchor — keep it fixed so other vertices stay put
    draw();
    return;
  }

  if(mode === 'DRAGGING_ANCHOR' && activeIndex !== -1){
    const s = shapes[activeIndex];
    s.anchor.x = mouseWorld.x - s.tx;
    s.anchor.y = mouseWorld.y - s.ty;
    draw();
    return;
  }

  if(mode === 'DRAGGING_SHAPE' && activeIndex !== -1){
    const s = shapes[activeIndex];
    const dx = mouseWorld.x - dragStartWorld.x;
    const dy = mouseWorld.y - dragStartWorld.y;
    s.tx += dx;
    s.ty += dy;
    dragStartWorld = { ...mouseWorld };
    if(!s.anim.x) document.getElementById('inputTx').value = s.tx;
    if(!s.anim.y) document.getElementById('inputTy').value = s.ty;
    updateLabelValues();
    draw();
    return;
  }

  draw();
});

canvas.addEventListener('mouseup', (e)=>{
  if(isPanning){
    isPanning = false;
    canvas.style.cursor = mode === 'DRAWING' ? 'crosshair' : 'default';
  }
  if(mode === 'DRAGGING_VERTEX'){
    mode = 'IDLE';
    draggingVertexIndex = -1;
  }
  if(mode === 'DRAGGING_ANCHOR' || mode === 'DRAGGING_SHAPE'){
    mode = 'IDLE';
  }
});

canvas.addEventListener('mouseleave', ()=>{
  isPanning = false;
  if(mode === 'DRAGGING_VERTEX'){
    mode = 'IDLE';
    draggingVertexIndex = -1;
  }
  if(mode === 'DRAGGING_ANCHOR' || mode === 'DRAGGING_SHAPE'){
    mode = 'IDLE';
  }
});

/* ===================== INSTRUÇÃO ===================== */
function showInstruction(text){
  const el = document.getElementById('instructionText');
  el.textContent = text;
  el.style.display = 'flex';
}

function hideInstruction(){
  document.getElementById('instructionText').style.display = 'none';
}

/* ===================== DESENHO ===================== */
function draw(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(view.offsetX, view.offsetY);
  ctx.scale(view.scale, view.scale);

  drawGrid();
  drawAxes();

  shapes.forEach((shape, idx) => {
    const isSelected = idx === activeIndex;
    const isGhost = false;
    drawShape(shape, isGhost, isSelected);
  });

  if(mode === 'DRAWING' && activeIndex !== -1){
    const s = shapes[activeIndex];
    if(s.points.length > 0 && s.type === SHAPE_TYPES.POLYGON){
      ctx.save();
      ctx.strokeStyle = s.color + '88';
      ctx.lineWidth = 1.5 / view.scale;
      ctx.setLineDash([4/view.scale, 4/view.scale]);
      ctx.beginPath();
      ctx.moveTo(s.points[s.points.length-1].x, s.points[s.points.length-1].y);
      ctx.lineTo(mouseWorld.x, mouseWorld.y);
      ctx.stroke();
      ctx.restore();

      if(s.points.length >= 3){
        const first = s.points[0];
        const distWorld = Math.hypot(mouseWorld.x - first.x, mouseWorld.y - first.y);
        const threshold = 15 / view.scale;
        if(distWorld < threshold){
          ctx.save();
          ctx.beginPath();
          ctx.arc(first.x, first.y, threshold, 0, Math.PI*2);
          ctx.fillStyle = s.color + '33';
          ctx.fill();
          ctx.strokeStyle = s.color;
          ctx.lineWidth = 2 / view.scale;
          ctx.setLineDash([]);
          ctx.stroke();
          ctx.restore();
        }
      }
    }
  }

  ctx.restore();
}

function drawGrid(){
  const step = 40;
  // These bounds are in world coords (we're already inside the ctx transform)
  const left = -view.offsetX / view.scale;
  const top = -view.offsetY / view.scale;
  const right = (canvas.width - view.offsetX) / view.scale;
  const bottom = (canvas.height - view.offsetY) / view.scale;
  
  ctx.save();
  ctx.strokeStyle = 'rgba(220,220,220,0.9)';
  ctx.lineWidth = 0.5 / view.scale;
  
  // Start from exact multiples of step so grid lines always pass through world origin (0,0)
  const startX = Math.ceil(left / step) * step;
  const startY = Math.ceil(top / step) * step;

  for(let x = startX; x <= right + step; x += step){
    ctx.beginPath();
    ctx.moveTo(x, top);
    ctx.lineTo(x, bottom);
    ctx.stroke();
  }
  for(let y = startY; y <= bottom + step; y += step){
    ctx.beginPath();
    ctx.moveTo(left, y);
    ctx.lineTo(right, y);
    ctx.stroke();
  }
  ctx.restore();
}

function drawAxes(){
  const left = -view.offsetX / view.scale;
  const top = -view.offsetY / view.scale;
  const right = (canvas.width - view.offsetX) / view.scale;
  const bottom = (canvas.height - view.offsetY) / view.scale;

  ctx.save();
  ctx.strokeStyle = 'rgba(175,175,175,0.6)';
  ctx.lineWidth = 1 / view.scale;

  ctx.beginPath();
  ctx.moveTo(left, 0);
  ctx.lineTo(right, 0);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, top);
  ctx.lineTo(0, bottom);
  ctx.stroke();

  ctx.restore();
}

function getTransformedPoints(shape){
  if(shape.type === SHAPE_TYPES.CIRCLE){
    const cx = shape.points[0].x + shape.tx;
    const cy = shape.points[0].y + shape.ty;
    return [{ x: cx, y: cy }];
  }

  const angle = shape.rotation * Math.PI / 180;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const ax = shape.anchor.x;
  const ay = shape.anchor.y;
  const sx = shape.reflectX ? -1 : 1;
  const sy = shape.reflectY ? -1 : 1;
  const scale = shape.scale;

  return shape.points.map(p => {
    let dx = p.x - ax;
    let dy = p.y - ay;
    dx *= scale * sx;
    dy *= scale * sy;
    const rx = dx * cos - dy * sin;
    const ry = dx * sin + dy * cos;
    return {
      x: ax + rx + shape.tx,
      y: ay + ry + shape.ty
    };
  });
}

function drawShape(shape, isGhost, isSelected){
  ctx.save();

  const alpha = isGhost ? 0.3 : 1;
  ctx.globalAlpha = alpha;

  ctx.fillStyle = shape.color + '30';
  ctx.strokeStyle = shape.color;
  ctx.lineWidth = (isSelected ? 2.5 : 1.8) / view.scale;
  ctx.setLineDash([]);

  if(isSelected){
    ctx.shadowColor = shape.color;
    ctx.shadowBlur = 8 / view.scale;
  }

  const pivotX = shape.anchor.x + shape.tx;
  const pivotY = shape.anchor.y + shape.ty;

  switch(shape.type){
    case SHAPE_TYPES.POINT:
      drawPoint(shape, isGhost, isSelected);
      break;
    case SHAPE_TYPES.SEGMENT:
      drawSegment(shape);
      break;
    case SHAPE_TYPES.LINE:
      drawLine(shape);
      break;
    case SHAPE_TYPES.CIRCLE:
      drawCircle(shape);
      break;
    case SHAPE_TYPES.POLYGON:
      drawPolygon(shape);
      break;
  }
  
  ctx.restore();
  
  if(isSelected && !isGhost && shape.type !== SHAPE_TYPES.POINT){
    drawAnchor(pivotX, pivotY);
  }

  // Draw draggable vertex handles on selected, closed polygon
  if(isSelected && !isGhost && shape.isClosed && 
     (shape.type === SHAPE_TYPES.POLYGON || shape.type === SHAPE_TYPES.SEGMENT)){
    drawVertexHandles(shape);
  }
}

function drawVertexHandles(shape){
  ctx.save();
  const r = 6 / view.scale;
  const transformed = getTransformedPoints(shape);
  transformed.forEach((p, i) => {
    const isBeingDragged = (mode === 'DRAGGING_VERTEX' && draggingVertexIndex === i);

    // Outer ring
    ctx.beginPath();
    ctx.arc(p.x, p.y, r * (isBeingDragged ? 1.4 : 1), 0, Math.PI * 2);
    ctx.fillStyle = isBeingDragged ? shape.color : '#FFFFFF';
    ctx.fill();
    ctx.strokeStyle = shape.color;
    ctx.lineWidth = 2 / view.scale;
    ctx.stroke();

    // Inner dot
    ctx.beginPath();
    ctx.arc(p.x, p.y, r * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = shape.color;
    ctx.fill();
  });
  ctx.restore();
}

function drawPoint(shape, isGhost, isSelected){
  const p = shape.points[0];
  const r = shape.pointRadius / view.scale;
  
  ctx.beginPath();
  ctx.arc(p.x, p.y, r, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  
  if(isSelected && !isGhost){
    ctx.beginPath();
    ctx.arc(p.x, p.y, r * 1.5, 0, Math.PI*2);
    ctx.fillStyle = shape.color + "22";
    ctx.fill();
  }
}

function drawSegment(shape){
  if(shape.points.length < 2) return;
  const pts = getTransformedPoints(shape);
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  ctx.lineTo(pts[1].x, pts[1].y);
  ctx.stroke();
  
  ctx.fillStyle = shape.color;
  pts.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3/view.scale, 0, Math.PI*2);
    ctx.fill();
  });
}

function drawLine(shape){
  if(shape.points.length < 2) return;
  const pts = getTransformedPoints(shape);
  const p1 = pts[0];
  const p2 = pts[1];
  
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy);
  const unitX = dx / len;
  const unitY = dy / len;
  
  const ext = shape.lineLength;
  
  ctx.beginPath();
  ctx.moveTo(p1.x - unitX * ext, p1.y - unitY * ext);
  ctx.lineTo(p2.x + unitX * ext, p2.y + unitY * ext);
  ctx.stroke();
  
  ctx.fillStyle = shape.color;
  pts.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3/view.scale, 0, Math.PI*2);
    ctx.fill();
  });
}

function drawCircle(shape){
  const center = shape.points[0];
  const cx = center.x + shape.tx;
  const cy = center.y + shape.ty;
  const r = shape.radius * shape.scale;
  
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  
  ctx.beginPath();
  ctx.arc(cx, cy, 3/view.scale, 0, Math.PI*2);
  ctx.fillStyle = shape.color;
  ctx.fill();
}

function drawPolygon(shape){
  if(shape.points.length < 2) return;
  const pts = getTransformedPoints(shape);
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1; i<pts.length; i++){
    ctx.lineTo(pts[i].x, pts[i].y);
  }
  if(shape.isClosed) ctx.closePath();
  ctx.fill();
  ctx.stroke();

  if(!shape.isClosed){
    pts.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4/view.scale, 0, Math.PI*2);
      ctx.fillStyle = shape.color;
      ctx.fill();
    });
  }
}

function drawAnchor(x, y){
  ctx.save();
  ctx.beginPath();
  ctx.arc(x, y, 7/view.scale, 0, Math.PI*2);
  ctx.fillStyle = '#FF9600';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2/view.scale;
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(x - 10/view.scale, y);
  ctx.lineTo(x + 10/view.scale, y);
  ctx.moveTo(x, y - 10/view.scale);
  ctx.lineTo(x, y + 10/view.scale);
  ctx.strokeStyle = '#FF9600';
  ctx.lineWidth = 1.5/view.scale;
  ctx.stroke();
  ctx.restore();
}

/* ===== LÓGICA DO POPUP DE IDENTIFICAÇÃO ===== */
const popupState = { ano: null, turma: null };

function selectChip(tipo, valor, el) {
  popupState[tipo] = valor;
  const grupo = document.getElementById('grupo' + tipo.charAt(0).toUpperCase() + tipo.slice(1));
  grupo.querySelectorAll('.popup-chip').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected');
}

function entrarGeolab() {
  const nome = document.getElementById('inputNome').value.trim();
  const erro = document.getElementById('popupError');
  
  if (!nome || !popupState.ano || !popupState.turma) {
    erro.style.display = 'block';
    const box = document.getElementById('popupBox');
    box.style.animation = 'none';
    box.offsetHeight;
    box.style.animation = 'shake 0.4s ease';
    return;
  }
  
  erro.style.display = 'none';
  
  const identificacao = {
    nome,
    ano: popupState.ano,
    turma: popupState.turma,
    timestamp: new Date().toLocaleString('pt-BR')
  };
  sessionStorage.setItem('geolab_aluno', JSON.stringify(identificacao));
  
  document.getElementById('badgeNome').textContent = nome;
  document.getElementById('badgeInfo').textContent = `${popupState.ano} Ano | Turma ${popupState.turma}`;
  const badge = document.getElementById('studentBadge');
  badge.style.display = 'flex';
  
  const overlay = document.getElementById('popupOverlay');
  overlay.style.animation = 'fadeOutOverlay 0.4s ease forwards';
  setTimeout(() => {
    overlay.style.display = 'none';
  }, 400);
}

function abrirAreaProfessor() {
  document.getElementById('professorModal').classList.add('visible');
  document.getElementById('inputSenhaProfessor').value = '';
  document.getElementById('professorError').style.display = 'none';
  setTimeout(() => document.getElementById('inputSenhaProfessor').focus(), 100);
}

function fecharAreaProfessor() {
  document.getElementById('professorModal').classList.remove('visible');
}

function verificarSenhaProfessor() {
  const senha = document.getElementById('inputSenhaProfessor').value;
  const SENHA_PROFESSOR = 'geolab2025';
  
  if (senha === SENHA_PROFESSOR) {
    fecharAreaProfessor();
    const overlay = document.getElementById('popupOverlay');
    overlay.style.animation = 'fadeOutOverlay 0.4s ease forwards';
    setTimeout(() => {
      overlay.style.display = 'none';
    }, 400);
    
    const badge = document.getElementById('studentBadge');
    badge.style.display = 'flex';
    document.getElementById('badgeNome').textContent = 'Professor';
    document.getElementById('badgeInfo').textContent = 'Acesso Total';
  } else {
    const erro = document.getElementById('professorError');
    erro.style.display = 'block';
    document.getElementById('inputSenhaProfessor').style.borderColor = 'var(--red)';
    setTimeout(() => {
      document.getElementById('inputSenhaProfessor').style.borderColor = '';
    }, 1500);
  }
}

const extraStyles = document.createElement('style');
extraStyles.textContent = `
  @keyframes fadeOutOverlay {
    from { opacity: 1; }
    to   { opacity: 0; }
  }
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20%       { transform: translateX(-10px); }
    40%       { transform: translateX(10px); }
    60%       { transform: translateX(-8px); }
    80%       { transform: translateX(8px); }
  }
`;
document.head.appendChild(extraStyles);

window.addEventListener('DOMContentLoaded', () => {
  // Wire all chips via pointerdown — works regardless of CSS transforms or hardenPage
  document.querySelectorAll('.popup-chip').forEach(chip => {
    chip.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      const tipo = chip.dataset.tipo;
      const valor = chip.dataset.valor;
      selectChip(tipo, valor, chip);
    });
  });

  // Wire enter buttons
  document.getElementById('btnEntrar').addEventListener('click', entrarGeolab);
  document.getElementById('btnProfessor').addEventListener('click', abrirAreaProfessor);

  document.getElementById('inputNome').addEventListener('keydown', e => {
    if (e.key === 'Enter') entrarGeolab();
  });
  document.getElementById('inputSenhaProfessor').addEventListener('keydown', e => {
    if (e.key === 'Enter') verificarSenhaProfessor();
  });

  // Restore session
  const saved = sessionStorage.getItem('geolab_aluno');
  if (saved) {
    try {
      const id = JSON.parse(saved);
      document.getElementById('inputNome').value = id.nome;
      popupState.ano = id.ano;
      popupState.turma = id.turma;
      ['ano','turma'].forEach(tipo => {
        const val = id[tipo];
        const grupo = document.getElementById('grupo' + tipo.charAt(0).toUpperCase() + tipo.slice(1));
        if (grupo) {
          grupo.querySelectorAll('.popup-chip').forEach(c => {
            if (c.dataset.valor === val) c.classList.add('selected');
          });
        }
      });
    } catch(e) {}
  }
});
</script>
</body>
</html>
