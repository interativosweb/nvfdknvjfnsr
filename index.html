<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoLab - Vers√£o Est√°vel</title>
    <style>
        :root {
            --primary: #4f46e5;
            --secondary: #db2777; /* Rosa para simetria */
            --accent: #f59e0b;
            --bg-color: #f3f4f6;
            --panel-bg: #ffffff;
            --text: #1f2937;
            --border: #e5e7eb;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* --- ESQUERDA: CONTROLES --- */
        .sidebar-left {
            width: 300px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 20;
            box-shadow: 4px 0 15px rgba(0,0,0,0.05);
        }

        .scroll-area { flex: 1; overflow-y: auto; padding: 15px; }
        .header-box { padding: 15px; border-bottom: 1px solid var(--border); background: #f9fafb; }
        
        h1 { font-size: 1.4rem; color: var(--primary); margin: 0; font-weight: 800; }
        h2 { font-size: 0.8rem; color: #6b7280; text-transform: uppercase; border-bottom: 2px solid #eee; padding-bottom: 5px; margin: 15px 0 10px 0; font-weight: 700;}

        .control-group { background: #f8fafc; padding: 10px; border-radius: 6px; border: 1px solid var(--border); margin-bottom: 10px; }

        button { width: 100%; padding: 8px; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; margin-bottom: 5px; transition: 0.2s; font-size: 0.85rem; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: #4338ca; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-success { background: #10b981; color: white; }
        
        .btn-anim { background: #3b82f6; color: white; display: flex; align-items: center; justify-content: center; gap: 5px; }
        .btn-anim.active { background: #1d4ed8; box-shadow: inset 0 2px 5px rgba(0,0,0,0.3); }
        
        .btn-toggle { background: white; border: 1px solid #ccc; color: #555; }
        .btn-toggle.active { background: var(--secondary); color: white; border-color: var(--secondary); }

        input[type=range] { width: 100%; accent-color: var(--primary); margin: 5px 0; }
        label { display: flex; justify-content: space-between; font-size: 0.8rem; color: #4b5563; }

        /* --- DIREITA: MENU FLUTUANTE DE FIGURAS --- */
        .floating-layers {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 200px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 30;
            max-height: 80vh;
            overflow-y: auto;
        }

        .layer-item {
            padding: 8px 10px; margin-bottom: 4px; background: rgba(255,255,255,0.5); 
            border: 1px solid transparent; border-radius: 6px;
            cursor: pointer; display: flex; justify-content: space-between; align-items: center; 
            transition: all 0.2s; font-size: 0.85rem;
        }
        .layer-item:hover { background: #f3f4f6; }
        .layer-item.active { 
            background: white; 
            border-color: var(--primary); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            font-weight: bold;
            color: var(--primary);
        }
        .layer-status { width: 8px; height: 8px; border-radius: 50%; background: #ddd; }
        .layer-item.active .layer-status { background: var(--primary); }

        /* Speed Control Mini */
        .speed-control {
            display:flex; justify-content:space-between; margin-top:5px; background:rgba(0,0,0,0.05); padding:4px; border-radius:4px;
        }
        .speed-btn { width:20px; height:20px; padding:0; margin:0; line-height:1; display:flex; align-items:center; justify-content:center; background: #ccc; color:white;}
        .speed-txt { font-size:0.7rem; font-weight:bold; color:#555; align-self:center; }


        /* --- CANVAS --- */
        .main-content {
            flex: 1; position: relative;
            background-image: linear-gradient(#e5e7eb 1px, transparent 1px), linear-gradient(90deg, #e5e7eb 1px, transparent 1px);
            background-size: 40px 40px;
            overflow: hidden;
            cursor: default;
        }
        #canvas { display: block; width: 100%; height: 100%; }

        .instruction {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.95); padding: 8px 20px; border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-weight: bold; color: var(--primary); pointer-events: none;
            border: 1px solid var(--primary); font-size: 0.9rem;
        }

        .footer { font-size: 0.7rem; color: #9ca3af; text-align: center; padding: 10px; border-top: 1px solid var(--border); }
    </style>
</head>
<body>

    <aside class="sidebar-left">
        <div class="header-box">
            <h1>üìê GeoLab</h1>
            <p style="font-size: 0.75rem; margin:0; color:#666">Laborat√≥rio de Matem√°tica</p>
        </div>
        
        <div class="scroll-area" id="controlsPanel" style="display:none"> 
            
            <div class="control-group" style="border-left: 3px solid var(--accent);">
                <h2 style="margin-top:0; color:var(--accent); display:flex; justify-content:space-between;">
                    Centro da Figura
                </h2>
                <p style="font-size:0.7rem; color:#666; margin-bottom:5px;">Arraste o ponto laranja para mudar o eixo.</p>
                <button class="btn-toggle" onclick="resetAnchor()" style="font-size:0.75rem">Resetar Centro</button>
            </div>

            <div class="control-group">
                <h2>Transla√ß√£o</h2>
                <label>X: <span id="valTx">0</span></label>
                <input type="range" id="inputTx" min="-350" max="350" oninput="updateShapeData()">
                <button class="btn-anim" id="animXBtn" onclick="toggleAnim('x')">‚ñ∂ Animar X</button>
                
                <label>Y: <span id="valTy">0</span></label>
                <input type="range" id="inputTy" min="-350" max="350" oninput="updateShapeData()">
                <button class="btn-anim" id="animYBtn" onclick="toggleAnim('y')">‚ñ∂ Animar Y</button>

                <div class="speed-control">
                    <button class="speed-btn" onclick="changeSpeed('trans', -1)">-</button>
                    <span class="speed-txt">Velocidade: <span id="speedTransDisplay">1x</span></span>
                    <button class="speed-btn" onclick="changeSpeed('trans', 1)">+</button>
                </div>
            </div>

            <div class="control-group">
                <h2>Rota√ß√£o</h2>
                <label>√Çngulo: <span id="valRot">0¬∞</span></label>
                <input type="range" id="inputRot" min="0" max="360" oninput="updateShapeData()">
                <button class="btn-anim" id="animRotBtn" onclick="toggleAnim('rot')">‚ñ∂ Animar Rota√ß√£o</button>

                <div class="speed-control">
                    <button class="speed-btn" onclick="changeSpeed('rot', -1)">-</button>
                    <span class="speed-txt">Velocidade: <span id="speedRotDisplay">1x</span></span>
                    <button class="speed-btn" onclick="changeSpeed('rot', 1)">+</button>
                </div>
            </div>

            <div class="control-group">
                <h2>Simetria (Espelho)</h2>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                    <button id="btnRefX" class="btn-toggle" onclick="toggleReflect('x')">Espelho X</button>
                    <button id="btnRefY" class="btn-toggle" onclick="toggleReflect('y')">Espelho Y</button>
                </div>
            </div>

            <button class="btn-danger" onclick="deleteCurrentLayer()" style="margin-top:10px;">üóëÔ∏è Excluir Figura</button>
        </div>

        <div class="scroll-area" id="emptyStateMsg" style="text-align:center; color:#999; display:flex; flex-direction:column; justify-content:center;">
            <p>Nenhuma figura selecionada.</p>
        </div>

        <div class="footer">
            Desenvolvido por Gilberto Fernandes - Matem√°tica
        </div>
    </aside>

    <main class="main-content" id="mainArea">
        <div class="instruction" id="instructionText">Clique em "+ Nova Figura" para come√ßar</div>
        <canvas id="canvas"></canvas>
    </main>

    <div class="floating-layers">
        <button class="btn-success" onclick="createNewLayer()" style="margin-bottom:10px; box-shadow:0 2px 5px rgba(0,0,0,0.1); width: 100%; padding: 10px;">+ Nova Figura</button>
        <div id="layersList">
            </div>
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const mainArea = document.getElementById('mainArea');

    let shapes = []; 
    let activeIndex = -1;
    let mode = 'IDLE'; 
    let mousePos = { x: 0, y: 0 };
    let dragStart = { x: 0, y: 0 };
    
    // Cores s√≥lidas para as figuras
    const colors = ['#4f46e5', '#059669', '#d97706', '#7c3aed', '#db2777'];

    function resizeCanvas() {
        canvas.width = mainArea.clientWidth;
        canvas.height = mainArea.clientHeight;
        draw();
    }
    window.addEventListener('resize', resizeCanvas);
    setTimeout(resizeCanvas, 100);

    // --- GERENCIAMENTO ---

    function createNewLayer() {
        const newShape = {
            id: Date.now(),
            name: `Figura ${shapes.length + 1}`,
            points: [],
            color: colors[shapes.length % colors.length],
            isClosed: false,
            // Transforma√ß√µes
            tx: 0, ty: 0, rotation: 0,
            reflectX: false, reflectY: false,
            anchor: { x: 0, y: 0 },
            anim: { x: false, y: false, rot: false, dirX: 1, dirY: 1 },
            speed: { trans: 1.0, rot: 1.0 }
        };

        shapes.push(newShape);
        selectLayer(shapes.length - 1);
        mode = 'DRAWING';
        updateUI();
        document.getElementById('instructionText').style.display = 'block';
        document.getElementById('instructionText').innerText = `Criando ${newShape.name}: Clique para desenhar`;
    }

    function selectLayer(index) {
        if (index < 0 || index >= shapes.length) {
            activeIndex = -1;
            mode = 'IDLE';
        } else {
            if (activeIndex !== -1 && !shapes[activeIndex].isClosed) {
                alert("Feche a forma atual antes de trocar.");
                return;
            }
            activeIndex = index;
            mode = shapes[index].isClosed ? 'IDLE' : 'DRAWING';
        }
        updateUI();
        draw();
    }

    function deleteCurrentLayer() {
        if (activeIndex === -1) return;
        shapes.splice(activeIndex, 1);
        activeIndex = -1;
        mode = 'IDLE';
        updateUI();
        draw();
    }

    function updateUI() {
        const layersList = document.getElementById('layersList');
        layersList.innerHTML = '';
        
        shapes.forEach((shape, idx) => {
            const div = document.createElement('div');
            div.className = `layer-item ${idx === activeIndex ? 'active' : ''}`;
            div.onclick = () => selectLayer(idx);
            div.innerHTML = `<span class="layer-name">${shape.name}</span> <div class="layer-status"></div>`;
            layersList.appendChild(div);
        });

        const controls = document.getElementById('controlsPanel');
        const emptyMsg = document.getElementById('emptyStateMsg');
        
        if (activeIndex !== -1 && shapes[activeIndex].isClosed) {
            controls.style.display = 'block';
            emptyMsg.style.display = 'none';
            
            const s = shapes[activeIndex];
            document.getElementById('inputTx').value = s.tx;
            document.getElementById('inputTy').value = s.ty;
            document.getElementById('inputRot').value = s.rotation;
            
            document.getElementById('btnRefX').classList.toggle('active', s.reflectX);
            document.getElementById('btnRefY').classList.toggle('active', s.reflectY);
            
            document.getElementById('animXBtn').classList.toggle('active', s.anim.x);
            document.getElementById('animYBtn').classList.toggle('active', s.anim.y);
            document.getElementById('animRotBtn').classList.toggle('active', s.anim.rot);
            
            document.getElementById('instructionText').style.display = 'none';
            updateLabelValues();
        } else {
            controls.style.display = 'none';
            emptyMsg.style.display = 'flex';
        }
    }

    function updateShapeData() {
        if (activeIndex === -1) return;
        const s = shapes[activeIndex];
        s.tx = parseInt(document.getElementById('inputTx').value);
        s.ty = parseInt(document.getElementById('inputTy').value);
        s.rotation = parseInt(document.getElementById('inputRot').value);
        updateLabelValues();
        draw();
    }
    
    function updateLabelValues() {
        if (activeIndex === -1) return;
        const s = shapes[activeIndex];
        document.getElementById('valTx').innerText = s.tx;
        document.getElementById('valTy').innerText = -s.ty;
        document.getElementById('valRot').innerText = s.rotation + "¬∞";
        document.getElementById('speedTransDisplay').innerText = s.speed.trans + "x";
        document.getElementById('speedRotDisplay').innerText = s.speed.rot + "x";
    }

    // --- INTERA√á√ÉO ---

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;

        if (mode === 'DRAWING') {
            const s = shapes[activeIndex];
            if (s.points.length >= 3) {
                const dx = mousePos.x - s.points[0].x;
                const dy = mousePos.y - s.points[0].y;
                if (Math.hypot(dx, dy) < 20) {
                    canvas.style.cursor = 'pointer';
                    document.getElementById('instructionText').innerText = "Clique no in√≠cio para fechar!";
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
            draw();
            return;
        }

        if (mode === 'DRAGGING_ANCHOR') {
            const s = shapes[activeIndex];
            const center = getCentroid(s.points);
            // Anchor √© relativo ao centroide
            s.anchor.x = mousePos.x - (center.x + s.tx);
            s.anchor.y = mousePos.y - (center.y + s.ty);
            draw();
            return;
        }

        if (mode === 'DRAGGING_SHAPE') {
            const dx = mousePos.x - dragStart.x;
            const dy = mousePos.y - dragStart.y;
            const s = shapes[activeIndex];
            s.tx += dx;
            s.ty += dy;
            document.getElementById('inputTx').value = s.tx;
            document.getElementById('inputTy').value = s.ty;
            updateLabelValues();
            dragStart = { x: mousePos.x, y: mousePos.y };
            draw();
            return;
        }

        // Hover Check
        let cursor = 'default';
        if (activeIndex !== -1) {
            const s = shapes[activeIndex];
            const center = getCentroid(s.points);
            const anchorX = center.x + s.tx + s.anchor.x;
            const anchorY = center.y + s.ty + s.anchor.y;
            if (Math.hypot(mousePos.x - anchorX, mousePos.y - anchorY) < 10) cursor = 'move';
            else if (isPointInShape(mousePos, s)) cursor = 'grab';
        } else {
             for (let i = shapes.length - 1; i >= 0; i--) {
                if (shapes[i].isClosed && isPointInShape(mousePos, shapes[i])) {
                    cursor = 'pointer'; break;
                }
            }
        }
        canvas.style.cursor = cursor;
    });

    canvas.addEventListener('mousedown', (e) => {
        if (mode === 'DRAWING') {
            const s = shapes[activeIndex];
            if (s.points.length >= 3) {
                const dx = mousePos.x - s.points[0].x;
                const dy = mousePos.y - s.points[0].y;
                if (Math.hypot(dx, dy) < 20) {
                    s.isClosed = true;
                    mode = 'IDLE';
                    updateUI();
                    draw();
                    return;
                }
            }
            s.points.push({x: mousePos.x, y: mousePos.y});
            draw();
            return;
        }

        // Check Anchor click
        if (activeIndex !== -1) {
            const s = shapes[activeIndex];
            const center = getCentroid(s.points);
            const anchorX = center.x + s.tx + s.anchor.x;
            const anchorY = center.y + s.ty + s.anchor.y;
            if (Math.hypot(mousePos.x - anchorX, mousePos.y - anchorY) < 10) {
                mode = 'DRAGGING_ANCHOR';
                return;
            }
        }

        // Check Shape click
        let clickedIndex = -1;
        if (activeIndex !== -1 && isPointInShape(mousePos, shapes[activeIndex])) {
            clickedIndex = activeIndex;
        } else {
            for (let i = shapes.length - 1; i >= 0; i--) {
                if (shapes[i].isClosed && isPointInShape(mousePos, shapes[i])) {
                    clickedIndex = i;
                    break;
                }
            }
        }

        if (clickedIndex !== -1) {
            selectLayer(clickedIndex);
            mode = 'DRAGGING_SHAPE';
            dragStart = { x: mousePos.x, y: mousePos.y };
            canvas.style.cursor = 'grabbing';
        }
    });

    canvas.addEventListener('mouseup', () => {
        if (mode === 'DRAGGING_SHAPE' || mode === 'DRAGGING_ANCHOR') {
            mode = 'IDLE';
            canvas.style.cursor = 'default';
        }
    });

    // --- L√ìGICA E RENDER ---

    function getCentroid(points) {
        if (!points || points.length === 0) return {x:0, y:0};
        let sx = 0, sy = 0;
        points.forEach(p => { sx += p.x; sy += p.y; });
        return { x: sx / points.length, y: sy / points.length };
    }

    function isPointInShape(p, shape) {
        ctx.save();
        ctx.beginPath();
        const center = getCentroid(shape.points);
        const pivotX = center.x + shape.tx + shape.anchor.x;
        const pivotY = center.y + shape.ty + shape.anchor.y;
        
        ctx.translate(pivotX, pivotY);
        ctx.rotate(shape.rotation * Math.PI / 180);
        ctx.translate(-pivotX, -pivotY);
        ctx.translate(shape.tx, shape.ty);

        ctx.moveTo(shape.points[0].x, shape.points[0].y);
        for(let i=1; i<shape.points.length; i++) ctx.lineTo(shape.points[i].x, shape.points[i].y);
        ctx.closePath();
        const yes = ctx.isPointInPath(p.x, p.y);
        ctx.restore();
        return yes;
    }

    function toggleReflect(axis) {
        if (activeIndex === -1) return;
        const s = shapes[activeIndex];
        if (axis === 'x') s.reflectX = !s.reflectX;
        if (axis === 'y') s.reflectY = !s.reflectY;
        updateUI();
        draw();
    }

    function resetAnchor() {
        if(activeIndex === -1) return;
        shapes[activeIndex].anchor = {x:0, y:0};
        draw();
    }

    function toggleAnim(type) {
        if (activeIndex === -1) return;
        const s = shapes[activeIndex];
        s.anim[type] = !s.anim[type];
        updateUI();
        requestAnimationFrame(animateLoop);
    }

    function changeSpeed(type, dir) {
        if (activeIndex === -1) return;
        const s = shapes[activeIndex];
        if (dir > 0 && s.speed[type] < 4) s.speed[type] *= 2;
        else if (dir < 0 && s.speed[type] > 0.25) s.speed[type] /= 2;
        updateUI();
    }

    function animateLoop() {
        let activeAnim = false;
        shapes.forEach(s => {
            if(!s.isClosed) return;
            if(s.anim.x || s.anim.y || s.anim.rot) {
                activeAnim = true;
                if(s.anim.rot) s.rotation = (s.rotation + (1*s.speed.rot)) % 360;
                if(s.anim.x) {
                    s.tx += (2*s.speed.trans) * s.anim.dirX;
                    if(s.tx > 350 || s.tx < -350) s.anim.dirX *= -1;
                }
                if(s.anim.y) {
                    s.ty += (2*s.speed.trans) * s.anim.dirY;
                    if(s.ty > 350 || s.ty < -350) s.anim.dirY *= -1;
                }
            }
        });
        
        if (activeAnim) {
            draw();
            if(activeIndex !== -1) updateLabelValues();
            requestAnimationFrame(animateLoop);
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy); ctx.stroke();

        shapes.forEach((shape, index) => {
            const isSelected = (index === activeIndex);
            
            if (index === activeIndex && mode === 'DRAWING') {
                if (shape.points.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(shape.points[0].x, shape.points[0].y);
                    shape.points.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.strokeStyle = shape.color; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                    shape.points.forEach(p => {ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill();});
                }
                return;
            }

            if (!shape.isClosed) return;

            ctx.globalAlpha = isSelected ? 1.0 : 0.4;
            
            renderInstance(shape, 1, 1, false, isSelected);
            if (shape.reflectX) renderInstance(shape, -1, 1, true, isSelected);
            if (shape.reflectY) renderInstance(shape, 1, -1, true, isSelected);
            if (shape.reflectX && shape.reflectY) renderInstance(shape, -1, -1, true, isSelected);
            
            ctx.globalAlpha = 1.0;
        });
    }

    function renderInstance(shape, scX, scY, isGhost, isSelected) {
        const center = getCentroid(shape.points);
        ctx.save();

        const pivotX = center.x + shape.tx + shape.anchor.x;
        const pivotY = center.y + shape.ty + shape.anchor.y;

        ctx.translate(pivotX, pivotY);
        let rot = shape.rotation * Math.PI / 180;
        if (scX * scY < 0) rot *= -1;
        ctx.rotate(rot);
        ctx.scale(scX, scY);
        ctx.translate(-pivotX, -pivotY);
        ctx.translate(shape.tx, shape.ty);

        ctx.beginPath();
        ctx.moveTo(shape.points[0].x, shape.points[0].y);
        for(let i=1; i<shape.points.length; i++) ctx.lineTo(shape.points[i].x, shape.points[i].y);
        ctx.closePath();

        if (isGhost) {
            ctx.fillStyle = "rgba(219, 39, 119, 0.1)";
            ctx.strokeStyle = "rgba(219, 39, 119, 0.6)";
            ctx.setLineDash([4, 4]);
        } else {
            ctx.fillStyle = shape.color + "33";
            ctx.strokeStyle = shape.color;
            ctx.setLineDash([]);
        }
        
        ctx.lineWidth = isSelected ? (isGhost ? 2 : 3) : 1;
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        if (isSelected && !isGhost) {
            ctx.beginPath();
            ctx.arc(pivotX, pivotY, 5, 0, Math.PI*2);
            ctx.fillStyle = 'var(--accent)';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
</script>
</body>
</html>

